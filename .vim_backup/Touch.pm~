package Mixi::Skin::Touch;
use strict;
use warnings;

use base qw/
    Class::Accessor::Fast
    Mixi::Sales::Cached
/;

use Scalar::Util qw/blessed/;
use Digest::HMAC_SHA1 qw(
    hmac_sha1_hex
);
use Carp qw(croak);
use Params::Validate qw(:types);

use Nove::Core::Datetime qw/
    in_duration
/;

use Mixi::Log;
use Mixi::Convert;
use Nove::Core::Service::Backdoor;
use Mixi::Exception qw(throw);

use Mixi::Skin::Config;
use Mixi::Skin::Touch::Style;
use Mixi::Skin::Touch::DB;

use Mixi::ProfileActivity;
use Mixi::ProfileActivity::Config;

__PACKAGE__->mk_accessors(qw/
    skin_type
/);

use constant VALIDATION_RULE => {
    SKIN_ID   => { type => SCALAR, regex => qr/^\d+\z/  },
    GENRE_ID  => { type => SCALAR, regex => qr/^\d+\z/  },
    MEMBER_ID => { type => SCALAR, regex => qr/^\d+\z/  },
};

sub get_skin_css {
    my $class = shift;
    my %args = Params::Validate::validate(@_,{
        skin    => { type => HASHREF | UNDEF },
    });

    my $styler = Mixi::Skin::Touch::Style->new(
        { skin  => $args{skin}, }
    );

    return $styler->get_css();
}

sub get_instance {
    my $class = shift;

    croak 'this is class method.' if (Scalar::Util::blessed $class);

    if (is_skin_test_environment()) {
        $class .= "::Test";
        $class->require or die;
    }

    return $class->new(@_);
}

sub new {
    my $class = shift;
    my %args = (
        skin_type => Mixi::Skin::Config::TOUCH_SKIN_TYPE->{SIMPLE},
        @_
    );
    my $self = $class->SUPER::new(\%args);
    return $self;
}

sub db {
    my $self = shift;

    $self->{_instance_db} ||= Mixi::Skin::Touch::DB->new();
    return $self->{_instance_db}->adapter(@_);
}

sub get_genre {
    my $self = shift;
    my %args = Params::Validate::validate(@_,{ id => VALIDATION_RULE->{GENRE_ID} });
    return $self->db(-Skin=> { role => 's' })->select_genre_by_id(%args);
}

sub get_public_genres {
    my $self = shift;
    return $self->db(-Skin=> { role => 's' })->select_public_genres();
}

sub get_public_skins {
    my $self = shift;
    my %args = Params::Validate::validate(@_,{
        offset => { type => SCALAR | UNDEF,optional => 1 },
        count  => { type => SCALAR | UNDEF,optional => 1 },
    });

    my $skins = $self->db(-Skin=> { role => 's' })->select_public_skins((%args,skin_type => $self->skin_type));
    for(@{$skins || [] }){
        $_->{skin_base} = $self->_make_skin_base($_->{id},$_->{skin_version});
    }
    my $count = @$skins;

    return {
        count => $count,
        rows  => $skins,
    };
}

sub get_public_skins_by_genre {
    my $self = shift;
    my %args = Params::Validate::validate(@_,{
        genre_id => VALIDATION_RULE->{GENRE_ID},
        offset   => { type => SCALAR | UNDEF,optional => 1 },
        count    => { type => SCALAR | UNDEF,optional => 1 },
    });

    my $skins = $self->db(-Skin=> { role => 's' })->select_public_skins_by_genre((%args,skin_type => $self->skin_type));
    for(@{$skins || [] }){
        $_->{skin_base} = $self->_make_skin_base($_->{id},$_->{skin_version});
    }
    my $count = $self->db(-Skin=> { role => 's' })->select_found_rows();

    return {
        count => $count,
        rows  => $skins,
    };
}

sub get_skin {
    my ($self, %args) = @_;
    my $id = $args{id};
    return unless $id;

    ## @KEY: touch_skin:skin_data:<SKIN_ID> TOUCHスキン情報
    return $self->call_cached(-Format => {
        keyinfo => [Mixi::Skin::Config::CACHE->{TOUCH_SKIN_DATA}->{KEY},$id],
        expire  => Mixi::Skin::Config::CACHE->{TOUCH_SKIN_DATA}->{EXPIRE},
        code    => sub { $self->_get_skin($id); },
    });
}

sub get_staging_skin {
    my ($self, $id) = @_;
    my $skin = $self->_get_skin($id);
    return unless $skin;
    return unless $self->can_use_skin($skin);

    if($skin->{status} == Mixi::Skin::Config::SKIN_STATUS_DB->{CAN_OPEN_EDIT}){
        my $new_version = $self->_get_editing_skin_version($skin->{temporary_skin_info});
        $skin->{skin_version} = $new_version if $new_version;
        $skin->{skin_base} = $self->_make_skin_base($skin->{id},$skin->{skin_version});
    }

    return $skin;
}

sub set_member_skin {
    my ($self, %args) = @_;

    my $new_skin = $args{skin};

    my $db = $self->db(-Skin=> { role => 'm' });
    eval {
        $db->insert_member_skin_relation(
            member_id => $args{member_id},
            skin_id   => $new_skin->{id},
        );
    };

    if($@){
        Mixi::Log->new->warn("faild to set_member_skin [$@]");
        return;
    }
    $self->delete_cached(-Format => [Mixi::Skin::Config::CACHE->{TOUCH_MEMBER_SKIN}->{KEY},$args{member_id}]);

    return 1;
}

sub delete_member_skin {
    my ($self, %args) = @_;
    my $db = $self->db(-Skin=> { role => 'm' });
    eval {
        $db->delete_member_skin_relation(%args);
    };

    if($@){
        Mixi::Log->new->warn("faild to delete_member_skin [$@]");
        return;
    }
    $self->delete_cached(-Format => [Mixi::Skin::Config::CACHE->{TOUCH_MEMBER_SKIN}->{KEY},$args{member_id}]);

    return 1;
}

sub get_member_skin {
    my $self = shift;
    my %args = Params::Validate::validate(@_, { member_id => VALIDATION_RULE->{MEMBER_ID} });

    ## @KEY: pc_skin:member_skin:<MEMBER_ID> ユーザが着用しているTouchスキンのID
    my $skin_id  = $self->call_cached(-Format => {
        keyinfo => [Mixi::Skin::Config::CACHE->{TOUCH_MEMBER_SKIN}->{KEY},$args{member_id}],
        expire  => Mixi::Skin::Config::CACHE->{TOUCH_MEMBER_SKIN}->{EXPIRE},
        code    => sub{
            return $self->db(-Skin=> { role => 's' })->select_member_skin_id(
        member_id => $args{member_id},
    );
        }
    });

    return unless $skin_id;
    return $self->get_skin(id => $skin_id);
}

sub get_members {
    my $self = shift;
    my %args = Params::Validate::validate(@_, {
        skin_id => VALIDATION_RULE->{SKIN_ID},
        role    => { default => 's', },
    });
    return $self->db(-Skin => { role => $args{role} })->select_skin_member_ids(
        skin_id => $args{skin_id},
    );
}

# get uncached skin
sub _get_skin {
    my ($self,$id) = @_;
    return unless $id;

    my $skin = $self->db(-Skin=> { role => 's' })->select_skin_by_id(id => $id);
    $skin->{skin_base} = $self->_make_skin_base($skin->{id}, $skin->{skin_version}) if $skin;
    return $skin;

}

sub can_use_skin {
    my ($self,$skin) = @_;
    return unless defined $skin || $skin->{status};
    return $skin->{status} == Mixi::Skin::Config::SKIN_STATUS_DB->{CAN_OPEN} || $skin->{status} == Mixi::Skin::Config::SKIN_STATUS_DB->{CAN_OPEN_EDIT};
}

sub can_set_skin {
    1;
}

sub _make_skin_base {
    my ( $self, $id, $version) = @_;
    my $digest = Digest::HMAC_SHA1::hmac_sha1_hex( join( "_", $id, $version), Mixi::Skin::Config::TOUCH_SKIN_SECRET );
    return Mixi::Skin::Config::TOUCH_SKIN_BASE_PATH . "/" . $digest;
}

sub _get_editing_skin_version {
    my ($self,$skin_info) = @_;
    return unless $skin_info;

    my $obj;
    eval {
        my $engine  = Mixi::Convert->new('YAML');
        $obj = $engine->decode($skin_info);
    };
    if($@){
        Mixi::Log->new->warn("faild to convert yaml [$@]");
    }
    return unless $obj;
    return $obj->{skin_version};
}

sub is_skin_test_environment {
    return $ENV{SKIN_TEST_ENVIRONMENT};
}

1;
