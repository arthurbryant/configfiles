package Mixi::Skin::Touch;

use strict;
use warnings;
use parent qw/
    Class::Accessor::Fast
    Mixi::Sales::Cached
/;

#::<<other>>
use Carp qw(croak);
use Scalar::Util qw/blessed/;
use Params::Validate;
use Digest::HMAC_SHA1 qw/
    hmac_sha1_hex
/;
use Date::Calc;

#::<<core library>>
use Nove::Core::Log;
use Nove::Core::Settings::Converter;
use Nove::Core::Datetime qw/
    in_duration
/;

#::<<common library>>
use Mixi;
use Mixi::String;
use Mixi::Picture::OnetimeURL;

#::<<service>>
use Mixi::UserEvent;

#::<<application>>
use Mixi::Skin::Touch::Config;
use Mixi::Skin::Touch::DB::Skin;

#::CONSTANTS
use constant VALIDATION_RULE => {
    SKIN_ID     => { type => Params::Validate::SCALAR, regex => qr/^\d+\z/  },
    SKIN_TYPE   => { type => Params::Validate::SCALAR, regex => qr/^\d+\z/  },
    GENRE_ID    => { type => Params::Validate::SCALAR, regex => qr/^\d+\z/  },
    MEMBER_ID   => { type => Params::Validate::SCALAR, regex => qr/^\d+\z/  },
    CONTENT_ID  => { type => Params::Validate::SCALAR, regex => qr/^\d+\z/  },
    CONTENT_IDS => { type => Params::Validate::ARRAYREF },
};
use constant NAME_MAX_LENGTH => 40;
use constant NAME_CUT_SUFFIX => '...';

sub get_instance {
    my $class = shift;

    croak 'this is class method.' if (Scalar::Util::blessed $class);

    return $class->new(@_);
}

sub db {
    my $self = shift;
    Mixi::Skin::Touch::DB::Skin->new(@_);
}

sub get_genre {
    my $self = shift;
    my %args = Params::Validate::validate(@_,{ id => VALIDATION_RULE->{GENRE_ID} });
    return $self->db({ role => 's' })->select_genre_by_id(%args);
}

sub get_public_genres_by_skin_id {
    my $self = shift;
    my %args = Params::Validate::validate(@_,{ skin_id => VALIDATION_RULE->{SKIN_ID} });
    return $self->db({ role => 's' })->select_public_genres_by_skin_id(%args);
}

sub get_public_genres {
    my $self = shift;
    return $self->db({ role => 's' })->select_public_genres();
}

sub get_public_skins_by_skin_type {
    my $self = shift;
    my %args = Params::Validate::validate(@_,{
        skin_type => VALIDATION_RULE->{SKIN_TYPE},
        offset    => {
            type => Params::Validate::SCALAR | Params::Validate::UNDEF,
            optional => 1
        },
        count     => {
            type => Params::Validate::SCALAR | Params::Validate::UNDEF,
            optional => 1
        },
    });

    my $db = $self->db({ role => 's' });

    my $count = $db->count_public_skins_by_skin_type(%args);
    my $skins = $db->select_public_skins_by_skin_type(%args);
    for my $skin (@{$skins || []}){
        $self->_fold_name($skin);
        $self->_set_skin_base($skin);
    }

    return {
        count => $count,
        rows  => $skins,
    };
}

sub get_public_skins {
    my $self = shift;
    my %args = Params::Validate::validate(@_,{
        offset => {
            type => Params::Validate::SCALAR | Params::Validate::UNDEF,
            optional => 1
        },
        count  => {
            type => Params::Validate::SCALAR | Params::Validate::UNDEF,
            optional => 1
        },
    });

    my $db = $self->db({ role => 's' });

    my $count = $db->count_public_skins(%args);
    my $skins = $db->select_public_skins(%args);
    for my $skin (@{$skins || []}){
        $self->_fold_name($skin);
        $self->_set_skin_base($skin);
    }

    return {
        count => $count,
        rows  => $skins,
    };
}

sub get_public_skins_by_genre {
    my $self = shift;
    my %args = Params::Validate::validate(@_,{
        genre_id => VALIDATION_RULE->{GENRE_ID},
        offset   => {
            type => Params::Validate::SCALAR | Params::Validate::UNDEF,
            optional => 1
        },
        count    => {
            type => Params::Validate::SCALAR | Params::Validate::UNDEF,
            optional => 1
        },
    });

    my $db = $self->db({ role => 's' });

    my $count = $db->count_public_skins_by_genre(%args);
    my $skins = $db->select_public_skins_by_genre(%args);
    for my $skin (@{$skins || []}){
        $self->_fold_name($skin);
        $self->_set_skin_base($skin);
    }

    return {
        count => $count,
        rows  => $skins,
    };
}

sub get_public_skins_by_genre_and_skin_type {
    my $self = shift;
    my %args = Params::Validate::validate(@_,{
        genre_id  => VALIDATION_RULE->{GENRE_ID},
        skin_type => VALIDATION_RULE->{SKIN_TYPE},
        offset    => {
            type => Params::Validate::SCALAR | Params::Validate::UNDEF,
            optional => 1
        },
        count     => {
            type => Params::Validate::SCALAR | Params::Validate::UNDEF,
            optional => 1
        },
    });

    my $db = $self->db({ role => 's' });
    my $count = $db->count_public_skins_by_genre_and_skin_type(%args);
    my $skins = $db->select_public_skins_by_genre_and_skin_type(%args);
    for my $skin (@{$skins || []}){
        $self->_fold_name($skin);
        $self->_set_skin_base($skin);
    }

    return {
        count => $count,
        rows  => $skins,
    };
}

sub get_skin_by_content_id {
    my $self = shift;
    my %args = Params::Validate::validate(@_, {
        content_id => VALIDATION_RULE->{CONTENT_ID},
    });

    my $content_id = $args{content_id};
    my $skin_map = $self->get_skin_map_by_content_ids(content_ids => [$content_id]);
    return unless $skin_map && $skin_map->{$content_id};
    return $skin_map->{$content_id};
}

sub get_skin_map_by_content_ids {
    my $self = shift;
    my %args = Params::Validate::validate(@_, {
        content_ids => VALIDATION_RULE->{CONTENT_IDS},
    });
    return unless scalar @{$args{content_ids}};

    my $db = $self->db({ role => 's' });
    my $skins = $db->select_skins_by_content_ids(%args);
    return unless $skins;

    for my $skin (@$skins){
        $self->_set_skin_base($skin);
    }

    return { map { ($_->{content_id} => $_) } @$skins };
}

sub get_skin {
    my $self = shift;
    my %args = Params::Validate::validate(@_, {
        id => VALIDATION_RULE->{SKIN_ID},
    });

    my $id = $args{id};
    return unless $id;

    if ($self->is_skin_test_environment) {
        my $skin = $self->get_staging_skin($id);
        return unless $self->can_use_skin($skin);
        return $skin;
    }

    my $skin = $self->call_cached(-Format => {
        keyinfo => [Mixi::Skin::Touch::Config::CACHE->{SKIN_DATA}->{KEY}, $id],
        expire  => Mixi::Skin::Touch::Config::CACHE->{SKIN_DATA}->{EXPIRE},
        code    => sub { $self->_get_skin_from_db($id); },
    });
    return unless ($skin && $self->can_use_skin($skin));

    $self->_set_skin_base($skin);
    return $skin;
}

sub get_staging_skin {
    my ($self, $id) = @_;
    my $skin = $self->_get_skin($id);
    return unless $skin;

    if($skin->{status} == Mixi::Skin::Touch::Config::SKIN_STATUS_DB->{CAN_OPEN_EDIT}){
        my $editing_skin = $self->_get_editing_skin_data($skin->{temporary_skin_info});
        return $skin unless $editing_skin;

        # Caution: Skin will be spoiled if temporary_skin_info has bad data.
        @{$skin}{keys %$editing_skin} = values %$editing_skin;
        $self->_set_skin_base($skin);
    }

    return $skin;
}

sub set_member_skin {
    my ($self, %args) = @_;

    my $new_skin = $args{skin};
    return unless $self->can_set_skin($new_skin);

    my $db = $self->db({ role => 'm' });
    eval {
        $db->insert_member_skin_relation(
            member_id => $args{member_id},
            skin_id   => $new_skin->{id},
        );
    };
    if (my $error = $@){
        Nove::Core::Log->warn("failed to set_member_skin [$error]");
        return;
    }
    $self->delete_cached(-Format => [Mixi::Skin::Touch::Config::CACHE->{MEMBER_SKIN}->{KEY},$args{member_id}]);

    Mixi::UserEvent->fire(
        'skin.touch.update' => {
            member_id => $args{member_id},
            skin_id   => $new_skin->{id},
            skin_type => $new_skin->{skin_type},
            timestamp => sprintf('%04d%02d%02d%02d%02d%02d', Date::Calc::Today_and_Now),
        }, 'dist_key' => $args{member_id}
    );

    return 1;
}

sub delete_member_skin {
    my $self = shift;
    my %args = Params::Validate::validate(@_, { member_id => VALIDATION_RULE->{MEMBER_ID} });

    my $db = $self->db({ role => 'm' });
    eval {
        $db->delete_member_skin_relation(%args);
    };

    if($@){
        Nove::Core::Log->warn("failed to delete_member_skin [$@]");
        return;
    }
    $self->delete_cached(-Format => [Mixi::Skin::Touch::Config::CACHE->{MEMBER_SKIN}->{KEY},$args{member_id}]);

    return 1;
}

sub get_member_skin {
    my $self = shift;
    my %args = Params::Validate::validate(@_, { member_id => VALIDATION_RULE->{MEMBER_ID} });

    my $skin_id  = $self->call_cached(-Format => {
        keyinfo => [Mixi::Skin::Touch::Config::CACHE->{MEMBER_SKIN}->{KEY},$args{member_id}],
        expire  => Mixi::Skin::Touch::Config::CACHE->{MEMBER_SKIN}->{EXPIRE},
        code    => sub {
            return $self->db({ role => 's' })->select_member_skin_id(
                member_id => $args{member_id},
            ) || 0; # instead of undef which won't be cached
        }
    });

    return unless $skin_id;
    return $self->get_skin(id => $skin_id);
}

# get uncached skin
sub _get_skin {
    my ($self, $id) = @_;

    my $skin = $self->_get_skin_from_db($id);
    return unless $skin;

    $self->_set_skin_base($skin);
    return $skin;
}

sub _get_skin_from_db {
    my ($self, $id) = @_;
    return unless $id;

    return $self->db({ role => 's' })->select_skin_by_id(id => $id);
}

sub can_use_skin {
    my ($self, $skin) = @_;
    return unless defined $skin;
    return unless defined $skin->{status};
    return 1 if $self->is_skin_test_environment && $skin->{status} == Mixi::Skin::Touch::Config::SKIN_STATUS_DB->{REGISTRATION};
    return (
        $skin->{status} == Mixi::Skin::Touch::Config::SKIN_STATUS_DB->{CAN_OPEN} ||
        $skin->{status} == Mixi::Skin::Touch::Config::SKIN_STATUS_DB->{CAN_OPEN_EDIT}
    );
}

sub can_set_skin {
    my ($self, $skin) = @_;

    return $self->can_use_skin($skin);
}

sub get_image_url_data {
    my ($self, $skin, $types) = @_;

    my $skin_base = ref $skin ? $skin->{skin_base} : $skin;
    my $skin_image_path_map = Mixi::Skin::Touch::Config::SKIN_IMAGE_PATH_MAP;

    my @types = ($types ? ( @$types ) : keys %$skin_image_path_map);
    return {
        map {
            my $path = $skin_base . $skin_image_path_map->{$_};
            ("skin_${_}_img_url" => Mixi::Picture::OnetimeURL->get_cp_img_url($path))
        } grep {
            $_ eq 'thumbnail' || $_ eq 'preview' || $skin->{"has_${_}_img"}
        } @types
    };
}

sub _make_skin_base {
    my ($self, $id, $version) = @_;
    my $digest = Digest::HMAC_SHA1::hmac_sha1_hex( join( "_", $id, $version), Mixi::Skin::Touch::Config::SKIN_SECRET);
    return Mixi::Skin::Touch::Config::SKIN_BASE_PATH . "/" . $digest;
}

sub _set_skin_base {
    my ($self, $skin) = @_;
    $skin->{skin_base} = $self->_make_skin_base($skin->{id}, $skin->{skin_version});
}

sub _fold_name {
    my ($self, $skin) = @_;
    $skin->{name} = Mixi::String::fold_text($skin->{name}, NAME_MAX_LENGTH, 1, NAME_CUT_SUFFIX);
}

sub _get_editing_skin_data {
    my ($class, $skin_info) = @_;
    return unless $skin_info;

    my $obj;
    eval {
        my $engine  = Nove::Core::Settings::Converter->new('YAML');
        $obj = $engine->decode($skin_info);
    };
    if($@){
        Nove::Core::Log->warn("failed to convert yaml [$@]");
    }
    return $obj;
}

sub is_skin_test_environment {
    return $ENV{SKIN_TEST_ENVIRONMENT};
}

1;

=pod

=encoding utf8

=head1 NAME

Mixi::Skin::Touch

=head1 AUTHOR

プロフィールユニット E<lt>unit-profile@mixi.co.jp<gt>

問い合わせはJIRA( http://jira.intra.mixi.co.jp/browse/PROFILE ) までお願いします。

=cut
