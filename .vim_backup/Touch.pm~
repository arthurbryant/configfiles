package Mixi::Skin::Touch;

use strict;
use warnings;
use parent qw/
    Class::Accessor::Fast
    Mixi::Sales::Cached
/;

#::<<other>>
use Carp qw(croak);
use Scalar::Util qw/blessed/;
use Mixi::Utils::Params::Validate;
use Params::Validate;
use Digest::HMAC_SHA1 qw/
    hmac_sha1_hex
/;
use Date::Calc;

#::<<core library>>
use Nove::Core::Log;
use Nove::Core::Settings::Converter;
use Nove::Core::Datetime qw/
    in_duration
/;

#::<<common library>>
use Mixi::String;

#::<<service>>
use Mixi::UserEvent;

#::<<application>>
use Mixi::Skin::Touch::Config;
use Mixi::Skin::Touch::DB::Skin;

#::CONSTANTS
use constant VALIDATION_RULE => {
    SKIN_ID     => { type => Params::Validate::SCALAR, regex => qr/^\d+\z/  },
    SKIN_TYPE   => { type => Params::Validate::SCALAR, regex => qr/^\d+\z/  },
    GENRE_ID    => { type => Params::Validate::SCALAR, regex => qr/^\d+\z/  },
    MEMBER_ID   => { type => Params::Validate::SCALAR, regex => qr/^\d+\z/  },
    CONTENT_IDS => { type => Params::Validate::ARRAYREF },
};
use constant NAME_MAX_LENGTH => 40;
use constant NAME_CUT_SUFFIX => '...';

sub get_instance {
    my $class = shift;

    croak 'this is class method.' if (Scalar::Util::blessed $class);

    return $class->new(@_);
}

sub db {
    my $self = shift;
    Mixi::Skin::Touch::DB::Skin->new(@_);
}

sub get_genre {
    my $self = shift;
    my %args = Params::Validate::validate(@_,{ id => VALIDATION_RULE->{GENRE_ID} });
    return $self->db({ role => 's' })->select_genre_by_id(%args);
}

sub get_public_genres_by_skin_id {
    my $self = shift;
    my %args = Params::Validate::validate(@_,{ skin_id => VALIDATION_RULE->{SKIN_ID} });
    return $self->db({ role => 's' })->select_public_genres_by_skin_id(%args);
}

sub get_public_genres {
    my $self = shift;
    return $self->db({ role => 's' })->select_public_genres();
}

sub get_public_skins_by_skin_type {
    my $self = shift;
    my %args = Params::Validate::validate(@_,{
        skin_type => VALIDATION_RULE->{SKIN_TYPE},
        offset    => {
            type => Params::Validate::SCALAR | Params::Validate::UNDEF,
            optional => 1
        },
        count     => {
            type => Params::Validate::SCALAR | Params::Validate::UNDEF,
            optional => 1
        },
    });

    my $db = $self->db({ role => 's' });

    my $count = $db->count_public_skins_by_skin_type(%args);
    my $skins = $db->select_public_skins_by_skin_type(%args);
    for(@{$skins || [] }){
        $_->{name}      = Mixi::String::fold_text($_->{name}, NAME_MAX_LENGTH, 1, NAME_CUT_SUFFIX);
        $_->{skin_base} = $self->_make_skin_base($_->{id},$_->{skin_version});
    }

    return {
        count => $count,
        rows  => $skins,
    };
}

sub get_public_skins {
    my $self = shift;
    my %args = Params::Validate::validate(@_,{
        offset => {
            type => Params::Validate::SCALAR | Params::Validate::UNDEF,
            optional => 1
        },
        count  => {
            type => Params::Validate::SCALAR | Params::Validate::UNDEF,
            optional => 1
        },
    });

    my $db = $self->db({ role => 's' });

    my $count = $db->count_public_skins(%args);
    my $skins = $db->select_public_skins(%args);
    for(@{$skins || [] }){
        $_->{name}      = Mixi::String::fold_text($_->{name}, NAME_MAX_LENGTH, 1, NAME_CUT_SUFFIX);
        $_->{skin_base} = $self->_make_skin_base($_->{id},$_->{skin_version});
    }
    return {
        count => $count,
        rows  => $skins,
    };
}

sub get_public_skins_by_genre {
    my $self = shift;
    my %args = Params::Validate::validate(@_,{
        genre_id => VALIDATION_RULE->{GENRE_ID},
        offset   => {
            type => Params::Validate::SCALAR | Params::Validate::UNDEF,
            optional => 1
        },
        count    => {
            type => Params::Validate::SCALAR | Params::Validate::UNDEF,
            optional => 1
        },
    });

    my $db = $self->db({ role => 's' });

    my $count = $db->count_public_skins_by_genre(%args);
    my $skins = $db->select_public_skins_by_genre(%args);
    for(@{$skins || [] }){
        $_->{name}      = Mixi::String::fold_text($_->{name}, NAME_MAX_LENGTH, 1, NAME_CUT_SUFFIX);
        $_->{skin_base} = $self->_make_skin_base($_->{id},$_->{skin_version});
    }

    return {
        count => $count,
        rows  => $skins,
    };
}

sub get_public_skins_by_genre_and_skin_type {
    my $self = shift;
    my %args = Params::Validate::validate(@_,{
        genre_id  => VALIDATION_RULE->{GENRE_ID},
        skin_type => VALIDATION_RULE->{SKIN_TYPE},
        offset    => {
            type => Params::Validate::SCALAR | Params::Validate::UNDEF,
            optional => 1
        },
        count     => {
            type => Params::Validate::SCALAR | Params::Validate::UNDEF,
            optional => 1
        },
    });

    my $db = $self->db({ role => 's' });
    my $count = $db->count_public_skins_by_genre_and_skin_type(%args);
    my $skins = $db->select_public_skins_by_genre_and_skin_type(%args);
    for(@{$skins || [] }){
        $_->{name}      = Mixi::String::fold_text($_->{name}, NAME_MAX_LENGTH, 1, NAME_CUT_SUFFIX);
        $_->{skin_base} = $self->_make_skin_base($_->{id},$_->{skin_version});
    }

    return {
        count => $count,
        rows  => $skins,
    };
}

sub get_skins_by_content_ids {
    my $self = shift;
    my %args = Params::Validate::validate(@_, {
        content_ids => VALIDATION_RULE->{CONTENT_IDS},
    });

    my $db = $self->db({ role => 's' });
    my $skins = $db->select_skins_by_content_ids(%args);

    for(@{$skins || [] }){
        $_->{name}      = Mixi::String::fold_text($_->{name}, NAME_MAX_LENGTH, 1, NAME_CUT_SUFFIX);
        $_->{skin_base} = $self->_make_skin_base($_->{id},$_->{skin_version});
    }
    return $skins;
}

sub get_skin {
    my $self = shift;
    my %args = Params::Validate::validate(@_, {
        id => VALIDATION_RULE->{SKIN_ID},
    });

    my $id = $args{id};
    return unless $id;

    if ($self->is_skin_test_environment) {
        my $skin = $self->get_staging_skin($id);
        return unless $self->can_use_skin($skin);
        return $skin;
    }

    ## @KEY: touch_skin:skin_data:<SKIN_ID> TOUCHスキン情報
    my $skin = $self->call_cached(-Format => {
        keyinfo => [Mixi::Skin::Touch::Config::CACHE->{SKIN_DATA}->{KEY}, $id],
        expire  => Mixi::Skin::Touch::Config::CACHE->{SKIN_DATA}->{EXPIRE},
        code    => sub { $self->_get_skin($id); },
    });
    return $skin if $self->can_use_skin($skin);
    return;
}

sub get_staging_skin {
    my ($self, $id) = @_;
    my $skin = $self->_get_skin($id);
    return unless $skin;

    if($skin->{status} == Mixi::Skin::Touch::Config::SKIN_STATUS_DB->{CAN_OPEN_EDIT}){
        my $editing_skin = $self->_get_editing_skin_data($skin->{temporary_skin_info});
        return $skin unless $editing_skin;

        # Caution: Skin will be spoiled if temporary_skin_info has bad data.
        @{$skin}{keys %$editing_skin} = values %$editing_skin;
        $skin->{skin_base} = $self->_make_skin_base($skin->{id}, $skin->{skin_version});
    }

    return $skin;
}

sub set_member_skin {
    my ($self, %args) = @_;

    my $new_skin = $args{skin};
    return unless $self->can_set_skin($new_skin);

    my $db = $self->db({ role => 'm' });
    eval {
        $db->insert_member_skin_relation(
            member_id => $args{member_id},
            skin_id   => $new_skin->{id},
        );
    };

    if($@){
        Nove::Core::Log->warn("failed to set_member_skin [$@]");
        return;
    }
    $self->delete_cached(-Format => [Mixi::Skin::Touch::Config::CACHE->{MEMBER_SKIN}->{KEY},$args{member_id}]);

    Mixi::UserEvent->fire(
        'skin.touch.update' => {
            member_id => $args{member_id},
            skin_id   => $new_skin->{id},
            skin_type => $new_skin->{skin_type},
            timestamp => sprintf('%04d%02d%02d%02d%02d%02d', Date::Calc::Today_and_Now),
        }, 'dist_key' => $args{member_id}
    );
    return 1;
}

sub delete_member_skin {
    my $self = shift;
    my %args = Params::Validate::validate(@_, { member_id => VALIDATION_RULE->{MEMBER_ID} });

    my $db = $self->db({ role => 'm' });
    eval {
        $db->delete_member_skin_relation(%args);
    };

    if($@){
        Nove::Core::Log->warn("failed to delete_member_skin [$@]");
        return;
    }
    $self->delete_cached(-Format => [Mixi::Skin::Touch::Config::CACHE->{MEMBER_SKIN}->{KEY},$args{member_id}]);

    return 1;
}

sub get_member_skin {
    my $self = shift;
    my %args = Params::Validate::validate(@_, { member_id => VALIDATION_RULE->{MEMBER_ID} });

    ## @KEY: pc_skin:member_skin:<MEMBER_ID> ユーザが着用しているTouchスキンのID
    my $skin_id  = $self->call_cached(-Format => {
        keyinfo => [Mixi::Skin::Touch::Config::CACHE->{MEMBER_SKIN}->{KEY},$args{member_id}],
        expire  => Mixi::Skin::Touch::Config::CACHE->{MEMBER_SKIN}->{EXPIRE},
        code    => sub {
            return $self->db({ role => 's' })->select_member_skin_id(
                member_id => $args{member_id},
            ) || 0; # instead of undef which won't be cached
        }
    });

    return unless $skin_id;
    return $self->get_skin(id => $skin_id);
}

# get uncached skin
sub _get_skin {
    my ($self,$id) = @_;
    return unless $id;

    my $skin = $self->db({ role => 's' })->select_skin_by_id(id => $id);
    $skin->{skin_base} = $self->_make_skin_base($skin->{id}, $skin->{skin_version}) if $skin;
    return $skin;
}

sub can_use_skin {
    my ($self,$skin) = @_;
    return unless defined $skin;
    return unless defined $skin->{status};
    return 1 if $self->is_skin_test_environment && $skin->{status} == Mixi::Skin::Touch::Config::SKIN_STATUS_DB->{REGISTRATION};
    return (
        $skin->{status} == Mixi::Skin::Touch::Config::SKIN_STATUS_DB->{CAN_OPEN} ||
        $skin->{status} == Mixi::Skin::Touch::Config::SKIN_STATUS_DB->{CAN_OPEN_EDIT}
    );
}

sub can_set_skin {
    my ($self,$skin) = @_;

    return $self->can_use_skin($skin) if $self->is_skin_test_environment;

    return unless defined $skin;
    return unless defined $skin->{status};
    return unless defined $skin->{open_datetime};
    return unless defined $skin->{close_datetime};
    return unless (
        $skin->{status} == Mixi::Skin::Touch::Config::SKIN_STATUS_DB->{CAN_OPEN} ||
        $skin->{status} == Mixi::Skin::Touch::Config::SKIN_STATUS_DB->{CAN_OPEN_EDIT}
    );
    return in_duration($skin->{open_datetime}, $skin->{close_datetime});
}

sub _make_skin_base {
    my ( $self, $id, $version) = @_;
    my $digest = Digest::HMAC_SHA1::hmac_sha1_hex( join( "_", $id, $version), Mixi::Skin::Touch::Config::SKIN_SECRET );
    return Mixi::Skin::Touch::Config::SKIN_BASE_PATH . "/" . $digest;
}

sub _get_editing_skin_data {
    my ($class, $skin_info) = @_;
    return unless $skin_info;

    my $obj;
    eval {
        my $engine  = Nove::Core::Settings::Converter->new('YAML');
        $obj = $engine->decode($skin_info);
    };
    if($@){
        Nove::Core::Log->warn("failed to convert yaml [$@]");
    }
    return $obj;
}

sub is_skin_test_environment {
    return $ENV{SKIN_TEST_ENVIRONMENT};
}

1;
