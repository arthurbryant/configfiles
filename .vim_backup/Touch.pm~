package Mixi::Skin::Touch;

use strict;
use warnings;
use base qw/
    Class::Accessor::Fast
    Mixi::Sales::Cached
/;

#::<<other>>
use Carp qw(croak);
use Scalar::Util qw/blessed/;
use Params::Validate;
use Digest::HMAC_SHA1 qw(
    hmac_sha1_hex
);

#::<<core library>>
use Nove::Core::Datetime qw/
    in_duration
/;

#::<<common library>>
use Mixi::Log;
use Mixi::Convert;
use Mixi::Exception qw(throw);

#::<<application>>
use Mixi::Skin::Config;
use Mixi::Skin::Touch::DB;
use Mixi::Skin::Touch::Style;

#::CONSTANTS
use constant VALIDATION_RULE => {
    SKIN_ID   => { type => Params::Validate::SCALAR, regex => qr/^\d+\z/  },
    GENRE_ID  => { type => Params::Validate::SCALAR, regex => qr/^\d+\z/  },
    MEMBER_ID => { type => Params::Validate::SCALAR, regex => qr/^\d+\z/  },
};

__PACKAGE__->mk_accessors(qw/
    skin_type
/);

sub get_skin_css {
    my $class = shift;
    my %args = Params::Validate::validate(@_,{
        skin    => { type => Params::Validate::HASHREF | Params::Validate::UNDEF },
    });

    my $styler = Mixi::Skin::Touch::Style->new(
        { skin  => $args{skin}, }
    );

    return $styler->get_css();
}

sub get_instance {
    my $class = shift;

    croak 'this is class method.' if (Scalar::Util::blessed $class);

    return $class->new(@_);
}

sub new {
    my $class = shift;
    my %args = (
        skin_type => Mixi::Skin::Config::TOUCH_SKIN_TYPE->{SIMPLE},
        @_
    );
    my $self = $class->SUPER::new(\%args);
    return $self;
}

sub db {
    my $self = shift;

    $self->{_instance_db} ||= Mixi::Skin::Touch::DB->new();
    return $self->{_instance_db}->adapter(@_);
}

sub get_genre {
    my $self = shift;
    my %args = Params::Validate::validate(@_,{ id => VALIDATION_RULE->{GENRE_ID} });
    return $self->db(-Skin=> { role => 's' })->select_genre_by_id(%args);
}

sub get_public_genres {
    my $self = shift;
    return $self->db(-Skin=> { role => 's' })->select_public_genres();
}

sub get_public_skins_by_skin_type {
    my $self = shift;
    my %args = Params::Validate::validate(@_,{
        offset => {
            type => Params::Validate::SCALAR | Params::Validate::UNDEF,
            optional => 1
        },
        count  => {
            type => Params::Validate::SCALAR | Params::Validate::UNDEF,
            optional => 1
        },
    });

    my $skins = $self->db(
        -Skin=> { role => 's' })->select_public_skins_by_skin_type(
            %args,
            skin_type => $self->skin_type
        );
    for(@{$skins || [] }){
        $_->{skin_base} = $self->_make_skin_base($_->{id},$_->{skin_version});
    }
    my $count = @$skins;

    return {
        count => $count,
        rows  => $skins,
    };
}

sub get_all_public_skins {
    my $self = shift;
    my %args = Params::Validate::validate(@_,{
        offset => {
            type => Params::Validate::SCALAR | Params::Validate::UNDEF,
            optional => 1
        },
        count  => {
            type => Params::Validate::SCALAR | Params::Validate::UNDEF,
            optional => 1
        },
    });
    my $skins = $self->db(-Skin=> { role => 's' })->select_all_public_skins(%args);
    for(@{$skins || [] }){
        $_->{skin_base} = $self->_make_skin_base($_->{id},$_->{skin_version});
    }
    my $count = @$skins;

    return {
        count => $count,
        rows  => $skins,
    };
}

sub get_all_public_skins_by_genre {
    my $self = shift;
    my %args = Params::Validate::validate(@_,{
        genre_id => VALIDATION_RULE->{GENRE_ID},
        offset   => {
            type => Params::Validate::SCALAR | Params::Validate::UNDEF,
            optional => 1
        },
        count    => {
            type => Params::Validate::SCALAR | Params::Validate::UNDEF,
            optional => 1
        },
    });

    my $skins = $self->db(-Skin=> { role => 's' })->select_all_public_skins_by_genre(
        %args,
    );
    for(@{$skins || [] }){
        $_->{skin_base} = $self->_make_skin_base($_->{id},$_->{skin_version});
    }
    my $count = $self->db(-Skin=> { role => 's' })->select_found_rows();

    return {
        count => $count,
        rows  => $skins,
    };
}

sub get_public_skins_by_genre_and_skin_type {
    my $self = shift;
    my %args = Params::Validate::validate(@_,{
        genre_id => VALIDATION_RULE->{GENRE_ID},
        offset   => {
            type => Params::Validate::SCALAR | Params::Validate::UNDEF,
            optional => 1
        },
        count    => {
            type => Params::Validate::SCALAR | Params::Validate::UNDEF,
            optional => 1
        },
    });

    my $skins = $self->db(-Skin=> { role => 's' })->select_public_skins_by_genre_and_skin_type(
        %args,
        skin_type => $self->skin_type
    );
    for(@{$skins || [] }){
        $_->{skin_base} = $self->_make_skin_base($_->{id},$_->{skin_version});
    }
    my $count = $self->db(-Skin=> { role => 's' })->select_found_rows();

    return {
        count => $count,
        rows  => $skins,
    };
}

sub get_skin {
    my $self = shift;
    my %args = Params::Validate::validate(@_, {
        id => VALIDATION_RULE->{SKIN_ID},
    });

    my $id = $args{id};
    return unless $id;

    if ($self->is_skin_test_environment) {
        my $skin = $self->get_staging_skin($id);
        return unless $self->can_use_skin($skin);
        return $skin;
    }

    ## @KEY: touch_skin:skin_data:<SKIN_ID> TOUCHスキン情報
    my $skin = $self->call_cached(-Format => {
        keyinfo => [Mixi::Skin::Config::CACHE->{TOUCH_SKIN_DATA}->{KEY}, $id],
        expire  => Mixi::Skin::Config::CACHE->{TOUCH_SKIN_DATA}->{EXPIRE},
        code    => sub { $self->_get_skin($id); },
    });
    return $skin if $self->can_use_skin($skin);
    return;
}

sub get_staging_skin {
    my ($self, $id) = @_;
    my $skin = $self->_get_skin($id);
    return unless $skin;

    if($skin->{status} == Mixi::Skin::Config::SKIN_STATUS_DB->{CAN_OPEN_EDIT}){
        my $editing_skin = $self->_get_editing_skin_data($skin->{temporary_skin_info});
        return $skin unless $editing_skin;

        # Caution: Skin will be spoiled if temporary_skin_info has bad data.
        @{$skin}{keys %$editing_skin} = values %$editing_skin;
        $skin->{skin_base} = $self->_make_skin_base($skin->{id}, $skin->{skin_version});
    }

    return $skin;
}

sub set_member_skin {
    my ($self, %args) = @_;

    my $new_skin = $args{skin};
    return unless $self->can_set_skin($new_skin);

    my $db = $self->db(-Skin=> { role => 'm' });
    eval {
        $db->insert_member_skin_relation(
            member_id => $args{member_id},
            skin_id   => $new_skin->{id},
        );
    };

    if($@){
        Mixi::Log->new->warn("faild to set_member_skin [$@]");
        return;
    }
    $self->delete_cached(-Format => [Mixi::Skin::Config::CACHE->{TOUCH_MEMBER_SKIN}->{KEY},$args{member_id}]);

    return 1;
}

sub delete_member_skin {
    my $self = shift;
    my %args = Params::Validate::validate(@_, { member_id => VALIDATION_RULE->{MEMBER_ID} });

    my $db = $self->db(-Skin=> { role => 'm' });
    eval {
        $db->delete_member_skin_relation(%args);
    };

    if($@){
        Mixi::Log->new->warn("faild to delete_member_skin [$@]");
        return;
    }
    $self->delete_cached(-Format => [Mixi::Skin::Config::CACHE->{TOUCH_MEMBER_SKIN}->{KEY},$args{member_id}]);

    return 1;
}

sub get_member_skin {
    my $self = shift;
    my %args = Params::Validate::validate(@_, { member_id => VALIDATION_RULE->{MEMBER_ID} });

    ## @KEY: pc_skin:member_skin:<MEMBER_ID> ユーザが着用しているTouchスキンのID
    my $skin_id  = $self->call_cached(-Format => {
        keyinfo => [Mixi::Skin::Config::CACHE->{TOUCH_MEMBER_SKIN}->{KEY},$args{member_id}],
        expire  => Mixi::Skin::Config::CACHE->{TOUCH_MEMBER_SKIN}->{EXPIRE},
        code    => sub {
            return $self->db(-Skin=> { role => 's' })->select_member_skin_id(
                member_id => $args{member_id},
            );
        }
    });

    return unless $skin_id;
    return $self->get_skin(id => $skin_id);
}

sub get_members {
    my $self = shift;
    my %args = Params::Validate::validate(@_, {
        skin_id => VALIDATION_RULE->{SKIN_ID},
        role    => { default => 's', },
    });
    return $self->db(-Skin => { role => $args{role} })->select_skin_member_ids(
        skin_id => $args{skin_id},
    );
}

# get uncached skin
sub _get_skin {
    my ($self,$id) = @_;
    return unless $id;

    my $skin = $self->db(-Skin=> { role => 's' })->select_skin_by_id(id => $id);
    $skin->{skin_base} = $self->_make_skin_base($skin->{id}, $skin->{skin_version}) if $skin;
    return $skin;

}

sub can_use_skin {
    my ($self,$skin) = @_;
    return unless defined $skin || $skin->{status};
    return 1 if $skin->{status} == Mixi::Skin::Config::SKIN_STATUS_DB->{REGISTRATION} && $self->is_skin_test_environment;
    return $skin->{status} == Mixi::Skin::Config::SKIN_STATUS_DB->{CAN_OPEN} || $skin->{status} == Mixi::Skin::Config::SKIN_STATUS_DB->{CAN_OPEN_EDIT};
}

sub can_set_skin {
    my ($self,$skin) = @_;

    return $self->can_use_skin($skin) if $self->is_skin_test_environment;

    return unless defined $skin || $skin->{status} || $skin->{open_datetime} || $skin->{close_datetime};
    return ( $skin->{status} == Mixi::Skin::Config::SKIN_STATUS_DB->{CAN_OPEN} || $skin->{status} == Mixi::Skin::Config::SKIN_STATUS_DB->{CAN_OPEN_EDIT} ) && in_duration($skin->{open_datetime},$skin->{close_datetime});
}

sub _make_skin_base {
    my ( $self, $id, $version) = @_;
    my $digest = Digest::HMAC_SHA1::hmac_sha1_hex( join( "_", $id, $version), Mixi::Skin::Config::TOUCH_SKIN_SECRET );
    return Mixi::Skin::Config::TOUCH_SKIN_BASE_PATH . "/" . $digest;
}

sub _get_editing_skin_data {
    my ($class, $skin_info) = @_;
    return unless $skin_info;

    my $obj;
    eval {
        my $engine  = Mixi::Convert->new('YAML');
        $obj = $engine->decode($skin_info);
    };
    if($@){
        Mixi::Log->new->warn("faild to convert yaml [$@]");
    }
    return $obj;
}

sub is_skin_test_environment {
    return $ENV{SKIN_TEST_ENVIRONMENT};
}

1;
