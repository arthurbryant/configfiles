package Mixi::Test::DataFactory::Object;

use strict;
use warnings;

use base qw(
    Class::Accessor::Fast
);

use Data::Dumper;
use Scalar::Util qw(
    blessed
);
use Params::Validate qw(
    BOOLEAN
    ARRAYREF
);
use UNIVERSAL::require;
use Carp qw(croak confess);
use Switch qw(switch case otherwise);
use Mixi::Test::Fixtures::Memcached;
use Mixi::Test::DataFactory::Attributes;
use Mixi::Test::DataFactory::Metadata;


__PACKAGE__->mk_ro_accessors(qw(
    blueprints
    metadata
    trace
));


sub new {
    my $class = shift;
    my %options = Params::Validate::validate(@_, {
                        trace => { type => BOOLEAN, default => 0 },
                    });
    

    return $class->SUPER::new({
                    %options,
                    blueprints => +{},
                    metadata   => +{},
                });
}

sub parse_blueprints {
    my $self = shift;
    my ($namespace, $source, $metadata) = @_;

    my @blueprints;
    $metadata = Mixi::Test::DataFactory::Metadata->new unless $metadata;

    if (ref $source eq 'ARRAY') {
        my @copy = @$source;
        my @names;
        my %mapping;

        while ( my ($name, $provider) = splice @copy, 0, 2 ) {
            if ($name =~ s/^-//) {
                switch ($name) {
                    case 'builder'        { $metadata->builder($provider) }
                    case 'object_builder' { $metadata->object_builder($provider) }
                    case 'before_create'  { $metadata->before_create($provider) }
                    case 'after_create'   { $metadata->after_create($provider) }
                    otherwise             { croak "Unknown configuration '$name' for namespace '$namespace'" }
                };
            }
            else {
                # 重複したものは上書きする
                push @names, $name unless exists $mapping{$name};
                $mapping{$name} = $provider;
            }
        }

        @blueprints = map { $_ => $mapping{$_} } @names;
    }
    elsif (ref $source eq 'HASH') {
        my ($base, $spec) = @$source{qw(base spec)};

        $self->require_blueprint($base);

        my $parent = $self->blueprint($base);
        my $md     = $self->metadata->{$base};

        croak "No base blueprint found: $base for namespace '$namespace'" if !$parent || !$md;
        return $self->parse_blueprints(
                    $namespace,
                    [ @$parent, @$spec ],
                    Mixi::Test::DataFactory::Metadata->new(+{ %$md }));
    }
    else {
        croak "blueprints must be ARRAY or HASH (namespace: '$namespace')";
    }

    return ($metadata, \@blueprints);
}

sub blueprint {
    my $self = shift;
    my ($namespace, @rest) = @_;

    if (@rest) {
        my ($metadata, $blueprints) = $self->parse_blueprints($namespace, @rest);

        $self->metadata->{$namespace}   = $metadata;
        $self->blueprints->{$namespace} = $blueprints;
    }

    return $self->blueprints->{$namespace};
}

sub activate {
    my $self = shift;

    for my $namespace (@_) {
        $self->require_blueprint($namespace);

        my $metadata = $self->_get_metadata($namespace);
        my $builder  = $metadata->builder;

        croak qq{No builder of "$namespace" found} if not defined $builder;
        $builder->activate if not $builder->active;
    }
}

sub _make_model {
    my $self = shift;
    my ($namespace, $params) = @_;

    if (not exists $self->blueprints->{$namespace}) {
        croak qq{No spec named "$namespace" found};
    }

    my %model;
    my @blueprint = @{ $self->blueprints->{$namespace} };
    # "-name" attributes
    my %attributes = map { $_ => delete $params->{$_} } grep { $_ =~ m/^-/ } keys %$params;
    my %missing;

    while ( my ($name, $provider) = splice @blueprint, 0, 2 ) {
        if (exists $params->{$name}) {
            # obey passed param even if it is undefined.
            # (because it will be valid NULL value for DBI)
            $provider = $params->{$name};
        }
        elsif (Mixi::Test::DataFactory::Attributes->is_required($provider)) {
            $missing{$name} = 1;
            next;
        }
        elsif (Mixi::Test::DataFactory::Attributes->is_optional($provider)) {
            next;
        }
        my $value = (ref $provider eq 'CODE') ? $provider->($self, \%model, \%attributes)
                                              : $provider;

        $model{$name} = $value;
    }

    return (\%model, \%attributes, \%missing);
}

sub _dynamic_load_namespace {
    my $self = shift;
    my ($namespace) = @_;

    # Nove::Core::Module::Loader can't handle error properly
    my $module = $namespace;
    $module =~ s/^Mixi::/Mixi::Test::DataFactory::Blueprint::/;

    unless ($module->require) {
        if ($@ && $@ !~ /Can't locate \S+ in \@INC/) {
            # Module not found is ok
            confess qq|Failed to load "$namespace" blueprint : $@|;
        }
        return;
    }

    return unless $module;
    return $module->new;
}

sub require_blueprint {
    my $self = shift;
    my ($namespace) = @_;

    return if exists $self->blueprints->{$namespace};

    warn qq|    Try to load "$namespace" dynamically| if $self->trace;
    my $blueprint = $self->_dynamic_load_namespace($namespace);
    warn "    >>> Loaded " . ref($blueprint) if $self->trace && $blueprint;

    return unless $blueprint;

    # TODO いつか Mixi::Test::DataFactory::Blueprint に統一したい
    $self->blueprint($namespace => $blueprint->to_plain_object);
    return $blueprint;
}

sub _get_metadata {
    my $self = shift;
    my ($namespace) = @_;

    confess qq{No metadata of "$namespace" found} unless $self->metadata->{$namespace};
    return $self->metadata->{$namespace}
}

sub make_object {
    my $self = shift;
    my ($namespace, $params) = @_;

    $self->require_blueprint($namespace);

    my $metadata = $self->_get_metadata($namespace);
    my $builder  = $metadata->object_builder;

    croak qq{No object builder of "$namespace" found} if not defined $builder;

    unless (blessed $builder && $builder->isa('Mixi::Test::DataFactory::Builder')) {
        croak "The 'object_builder' of '$namespace' is not an instance of 'Mixi::Test::DataFactory::Builder'.";
    }

    my ($model, $attributes) = $self->_make($namespace, $params);
    return $builder->build($self, $namespace, $model, $attributes);
}

sub _make {
    my $self = shift;
    my ($namespace, $params) = Params::Validate::validate_pos(@_, 1, 0);

    $self->require_blueprint($namespace);

    my $metadata = $self->_get_metadata($namespace);

    my ($model, $attributes, $missing) = $self->_make_model($namespace, $params);

    $metadata->run_callback_function('before_create', $self, $namespace, $model, $attributes);

    for my $name (keys %$missing) {
        next if $model->{$name};

        my $dumper = Data::Dumper->new([$model]);

        $dumper->Indent(0);
        $dumper->Terse(1);
        $dumper->Quotekeys(0);

        croak sprintf 'An attribute "%s" of "%s" (%s) is not supplied',
                $name, $namespace, $dumper->Dump;
    }

    my $builder = $metadata->builder;

    croak qq{No builder of "$namespace" found} if not defined $builder;
    $builder->activate if not $builder->active;

    $model = $builder->build($self, $namespace, +{ %$model }, $attributes);
    $metadata->run_callback_function('after_create', $self, $namespace, $model, $attributes);

    return ($model, $attributes);
}

sub make {
    my $self = shift;
    my ($model, $attributes) = $self->_make(@_);

    return $model;
}


1;
__END__

=head1 NAME

Mixi::Test::DataFactory::Object - OO interface


