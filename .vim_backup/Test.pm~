package Mixi::Skin::Test;
use strict;
use warnings;
use base qw(Mixi::Skin);

use Mixi::Skin::Config;

use Params::Validate qw(:types);

use constant VALIDATION_RULE => {
    SKIN_ID   => { type => SCALAR,regex => qr/^\d+\z/ },
    GENRE_ID  => { type => SCALAR,regex => qr/^\d+\z/ },
    MEMBER_ID => { type => SCALAR,regex => qr/^\d+\z/ },
};

sub get_public_skins {
    my $self = shift;
    my %args = Params::Validate::validate(@_,{ 
        offset => { type => SCALAR | UNDEF,optional => 1 },
        count  => { type => SCALAR | UNDEF,optional => 1 },
    });
    
    my $skins = $self->db(-Skin=> { role => 's' })->select_public_skins_for_test((%args,skin_type => $self->skin_type));
    my $count = $self->db(-Skin=> { role => 's' })->select_found_rows();

    for(@{$skins || [] }){
        #修正中のバージョンのミクコレデザイン保存ディレクトリから、cssおよび画像を配信する。
        if($_->{status} == Mixi::Skin::Config::SKIN_STATUS_DB->{CAN_OPEN_EDIT}){
            my $new_version = $self->_get_editing_skin_version($_->{temporary_skin_info});
            $_->{skin_version} = $new_version if $new_version;
        }
        $_->{skin_base} = $self->_make_skin_base($_->{id},$_->{skin_version});
    }

    return {
        rows  => $skins,
        count => $count
    };
}

sub get_skin {
    my $self = shift;
    my %args = Params::Validate::validate(@_, { id => VALIDATION_RULE->{SKIN_ID} });

    my $skin = $self->db(-Skin=> { role => 's' })->select_skin_by_id(id => $args{id});

    return unless defined $skin;

    if($skin->{status} == Mixi::Skin::Config::SKIN_STATUS_DB->{CAN_OPEN_EDIT}){
        my $new_version = $self->_get_editing_skin_version($skin->{temporary_skin_info});
        $skin->{skin_version} = $new_version if $new_version;
    }
    $skin->{skin_base} = $self->_make_skin_base($skin->{id},$skin->{skin_version});

    return unless $self->can_use_skin($skin);
    return $skin;
}

sub set_member_skin {
    my $self = shift;
    my %args = Params::Validate::validate(@_, {
        member_id       => VALIDATION_RULE->{MEMBER_ID},
        skin            => { type => HASHREF },
        via_script_name => { type => SCALAR  | UNDEF, optional => 1 },
    });

    my $new_skin = $args{skin};
    return unless $self->can_set_skin($new_skin);

    my $skin = $self->get_member_skin(member_id => $args{member_id});

    my $db = $self->db(-Skin=> { role => 'm' });
    $db->insert_member_skin_relation_for_test(
        member_id => $args{member_id},
        skin_id   => $new_skin->{id},
    );
    $self->delete_cached(-Format => [Mixi::Skin::Config::CACHE->{MEMBER_SKIN}->{KEY},$args{member_id}]);

    return 1;
}

sub get_member_skin {
    my $self = shift;
    my %args = Params::Validate::validate(@_, { member_id => VALIDATION_RULE->{MEMBER_ID} });

    my $skin_id = $self->db(-Skin=> { role => 's' })->select_member_skin_id_for_test( member_id => $args{member_id} );

    return unless $skin_id;
    return $self->get_skin(id => $skin_id);
}

sub delete_member_skin {
    my $self = shift;
    my %args = Params::Validate::validate(@_, { member_id => VALIDATION_RULE->{MEMBER_ID} });

    my $skin = $self->get_member_skin(member_id => $args{member_id});
    my $db = $self->db(-Skin=> { role => 'm' });
    $db->delete_member_skin_relation_for_test(%args);

    return 1;
}

#ミクコレ運用環境では登録中の状態のミクコレも利用可
sub can_use_skin {
    my ($self,$skin) = @_;
    return unless defined $skin || $skin->{status};
    return $skin->{status} == Mixi::Skin::Config::SKIN_STATUS_DB->{REGISTRATION} || $skin->{status} == Mixi::Skin::Config::SKIN_STATUS_DB->{CAN_OPEN} || $skin->{status} == Mixi::Skin::Config::SKIN_STATUS_DB->{CAN_OPEN_EDIT};
}

#ミクコレ運用環境では登録中の状態のミクコレも設定可
sub can_set_skin {
    my ($self,$skin) = @_;
    return unless defined $skin || $skin->{status};
    return $skin->{status} == Mixi::Skin::Config::SKIN_STATUS_DB->{REGISTRATION} || $skin->{status} == Mixi::Skin::Config::SKIN_STATUS_DB->{CAN_OPEN} || $skin->{status} == Mixi::Skin::Config::SKIN_STATUS_DB->{CAN_OPEN_EDIT};
}

1;

__END__

=pod

=encoding euc-jp

=head1 NAME

Mixi::Skin::Test

=head1 DESCRIPTION

新規追加および修正したミクコレのデザインチェックを行う環境のために特化した機能を提供する。

= cut

