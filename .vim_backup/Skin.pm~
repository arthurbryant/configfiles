package Mixi::Skin;
use strict;
use warnings;

use base qw/
    Class::Accessor::Fast Mixi::Sales::Cached/;

use Scalar::Util qw/blessed/;
use Digest::HMAC_SHA1 qw( 
    hmac_sha1_hex 
);
use Carp qw(croak);
use Params::Validate qw(:types);

use Nove::Core::Datetime qw/
    in_duration
/;
use Mixi::Log;
use Mixi::Convert;
use Nove::Core::Service::Backdoor;
use Mixi::Exception qw(throw);
use Mixi::Skin::DB;
use Mixi::Skin::Config;

use Mixi::ProfileActivity;
use Mixi::ProfileActivity::Config;

__PACKAGE__->mk_accessors(qw/
    skin_type
/);

use Mixi::Skin::Style;
use Mixi::Skin::Style::Classic;
use Mixi::Skin::Style::Old;
use Mixi::Skin::Style::None;
use Mixi::UserEvent;

use constant VALIDATION_RULE => {
    SKIN_ID   => { type => SCALAR, regex => qr/^\d+\z/  },
    GENRE_ID  => { type => SCALAR, regex => qr/^\d+\z/  },
    MEMBER_ID => { type => SCALAR, regex => qr/^\d+\z/  },
};

sub get_skin_css {
    my $class = shift;
    my %args = Params::Validate::validate(@_,{ 
        skin                   => { type => HASHREF | UNDEF },
        service                => { type => SCALAR  | UNDEF },
        mikukore               => { type => SCALAR },
        design                 => { type => SCALAR },
        colorvariation_base    => { type => SCALAR },
        colorvariation_service => { type => ARRAYREF },
        default_skin_base      => { type => SCALAR },
    });

    my $design = $args{design};

    my $styler;
    if($design eq '2010full'){
        $styler = Mixi::Skin::Style->new(
            skin                   => $args{skin},
            service                => $args{service},
            mikukore               => $args{mikukore},
            colorvariation_base    => $args{colorvariation_base},
            colorvariation_service => $args{colorvariation_service},
            default_skin_base      => $args{default_skin_base},
        );
    }elsif($design eq 'classic'){
        $styler = Mixi::Skin::Style::Classic->new(
            skin                   => $args{skin},
            service                => $args{service},
            mikukore               => $args{mikukore},
            colorvariation_base    => $args{colorvariation_base},
            colorvariation_service => $args{colorvariation_service},
            default_skin_base      => $args{default_skin_base},
        );
    }elsif($design eq 'old'){
        $styler = Mixi::Skin::Style::Old->new(
            skin                   => $args{skin},
            service                => $args{service},
            mikukore               => $args{mikukore},
            colorvariation_base    => $args{colorvariation_base},
            default_skin_base      => $args{default_skin_base},
        );
    }elsif($design eq 'none'){
        $styler = Mixi::Skin::Style::None->new(
            skin                   => $args{skin},
            service                => $args{service},
            mikukore               => $args{mikukore},
            colorvariation_base    => $args{colorvariation_base},
            colorvariation_service => $args{colorvariation_service},
            default_skin_base      => $args{default_skin_base},
        );
    }else{
      Mixi::Exception::throw "invalid parameters design : [$design]";
    }

    return $styler->get_css();
}

sub get_instance {
    my $class = shift;

    croak 'this is class method.' if (Scalar::Util::blessed $class);

    if (is_skin_test_environment()) {
        $class .= "::Test";
        $class->require or die;
    }

    return $class->new(@_);
}

sub new {
    my $class = shift;
    my %args = (
        skin_type => Mixi::Skin::Config::SKIN_TYPE->{SIMPLE},
        @_
    );
    my $self = $class->SUPER::new(\%args);
    return $self;
}

sub db {
    my $self = shift;
    $self->{_instance_db} ||= Mixi::Skin::DB->new();
    return $self->{_instance_db}->adapter(@_);
}

sub get_genre {
    my $self = shift;
    my %args = Params::Validate::validate(@_,{ id => VALIDATION_RULE->{GENRE_ID} });
    return $self->db(-Skin=> { role => 's' })->select_genre_by_id(%args);
}

sub get_public_genres {
    my $self = shift;
    return $self->db(-Skin=> { role => 's' })->select_public_genres(); 
}

sub get_public_skins {
    my $self = shift;
    my %args = Params::Validate::validate(@_,{ 
        offset => { type => SCALAR | UNDEF,optional => 1 },
        count  => { type => SCALAR | UNDEF,optional => 1 },
    });
    
    my $skins = $self->db(-Skin=> { role => 's' })->select_public_skins((%args,skin_type => $self->skin_type));
    for(@{$skins || [] }){
        $_->{skin_base} = $self->_make_skin_base($_->{id},$_->{skin_version});
    }
    my $count = $self->db(-Skin=> { role => 's' })->select_found_rows();

    return {
        count => $count,
        rows  => $skins,
    };
}

sub get_public_skins_by_genre {
    my $self = shift;
    my %args = Params::Validate::validate(@_,{ 
        genre_id => VALIDATION_RULE->{GENRE_ID},
        offset   => { type => SCALAR | UNDEF,optional => 1 },
        count    => { type => SCALAR | UNDEF,optional => 1 },
    });
    
    my $skins = $self->db(-Skin=> { role => 's' })->select_public_skins_by_genre((%args,skin_type => $self->skin_type));
    for(@{$skins || [] }){
        $_->{skin_base} = $self->_make_skin_base($_->{id},$_->{skin_version});
    }
    my $count = $self->db(-Skin=> { role => 's' })->select_found_rows();

    return {
        count => $count,
        rows  => $skins,
    };
}

sub get_skin {
    my $self = shift;
    my %args = Params::Validate::validate(@_, { id => VALIDATION_RULE->{SKIN_ID} });

    my $skin = $self->_get_skin($args{id});

    return unless defined $skin;
    return unless $self->can_use_skin($skin);

    return $skin;
}

sub set_member_skin {
    my $self = shift;
    my %args = Params::Validate::validate(@_, {
        member_id       => VALIDATION_RULE->{MEMBER_ID},
        skin            => { type => HASHREF },
        via_script_name => { type => SCALAR  | UNDEF, optional => 1 },
    });

    my $new_skin = $args{skin};
    return unless $self->can_set_skin($new_skin);

    my $script_id;
    $script_id = Mixi::Skin::Config::VIA_SCRIPT_NAMES->{$args{via_script_name}} if $args{via_script_name};

    my $skin = $self->get_member_skin(member_id => $args{member_id});

    my $db = $self->db(-Skin=> { role => 'm' });
    $db->begin();
    eval {
        #すでに設定しているミクコレがあればその利用終了を記録する。
        $db->set_skin_log_as_end(
            member_id => $args{member_id},
            skin_id   => $skin->{id},
        ) if $skin;

        $db->insert_member_skin_relation(
            member_id => $args{member_id},
            skin_id   => $new_skin->{id},
        );

        #ミクコレの利用開始を記録する。
        $db->set_skin_log_as_start(
            skin_id   => $new_skin->{id},
            member_id => $args{member_id},
            script_id => $script_id,
            extra_id  => 0,
        );
    };
    if($@){
        $db->rollback();
        Mixi::Log->new->warn("faild to set_member_skin [$@]");
        return;
    }
    $db->end();

    $self->delete_cached(-Format => [Mixi::Skin::Config::CACHE->{MEMBER_SKIN}->{KEY},$args{member_id}]);

    if(!Nove::Core::Service::Backdoor::is_masquerade_access()){
        Mixi::ProfileActivity->new()->update_activity(
            member_id => $args{member_id},
            feed_type => Mixi::ProfileActivity::Config::PROFILE_ACTIVITY_FEED_TYPE->{PC_SKIN},
            level     => Mixi::ProfileActivity::Config::PROFILE_ACTIVITY_FEED_LEVEL->{PUBLIC},
            extra     => {
                format_param => {
                    skin_name => $new_skin->{name},
                },
            },
        );
    }

    fire Mixi::UserEvent('profile.skin.action', {
        member_id => $args{member_id},
        new_skin_id => $new_skin->{id},
        old_skin_id => $skin->{id},
        referer => $args{via_script_name},
        device => 'pc',
        action => 'update_skin_free',
    });

    return 1;
}

sub delete_member_skin {
    my $self = shift;
    my %args = Params::Validate::validate(@_, { member_id => VALIDATION_RULE->{MEMBER_ID} });

    my $skin = $self->get_member_skin(member_id => $args{member_id});

    my $db = $self->db(-Skin=> { role => 'm' });
    $db->begin();
    eval {
        #ミクコレの利用終了を記録する。
        $db->set_skin_log_as_end(
            member_id => $args{member_id},
            skin_id   => $skin->{id},
        ) if $skin;

        $db->delete_member_skin_relation(%args);
    };
    if($@){
        $db->rollback();
        Mixi::Log->new->warn("faild to delete_member_skin [$@]");
        return;
    }
    $db->end();
    $self->delete_cached(-Format => [Mixi::Skin::Config::CACHE->{MEMBER_SKIN}->{KEY},$args{member_id}]);

    if(!Nove::Core::Service::Backdoor::is_masquerade_access()){
        Mixi::ProfileActivity->new()->delete_activity(
            member_id => $args{member_id},
            feed_type => Mixi::ProfileActivity::Config::PROFILE_ACTIVITY_FEED_TYPE->{PC_SKIN},
        );
    }

    return 1;
}

sub get_member_skin {
    my $self = shift;
    my %args = Params::Validate::validate(@_, { member_id => VALIDATION_RULE->{MEMBER_ID} });

    ## @KEY: pc_skin:member_skin:<MEMBER_ID> ユーザが着用しているPCスキンのID
    my $skin_id  = $self->call_cached(-Format => {
        keyinfo => [Mixi::Skin::Config::CACHE->{MEMBER_SKIN}->{KEY},$args{member_id}],
        expire  => Mixi::Skin::Config::CACHE->{MEMBER_SKIN}->{EXPIRE},
        code    => sub{
            return $self->db(-Skin=> { role => 's' })->select_member_skin_id(
                member_id => $args{member_id},
            ) || 0; # instead of undef which won't be cached
        }
    });

    return unless $skin_id;
    return $self->get_skin(id => $skin_id);
}

sub get_members {
    my $self = shift;
    my %args = Params::Validate::validate(@_, {
        skin_id => VALIDATION_RULE->{SKIN_ID},
        role    => { default => 's', },
    });
    return $self->db(-Skin => { role => $args{role} })->select_skin_member_ids(
        skin_id => $args{skin_id},
    );
}

sub _get_skin {
    my ($self,$id) = @_;
    return unless $id;

    ## @KEY: pc_skin:skin_data:<SKIN_ID> PCスキン情報
    return $self->call_cached(-Format => {
        keyinfo => [Mixi::Skin::Config::CACHE->{SKIN_DATA}->{KEY},$id],
        expire  => Mixi::Skin::Config::CACHE->{SKIN_DATA}->{EXPIRE},
        code    => sub {
            my $skin = $self->db(-Skin=> { role => 's' })->select_skin_by_id(id => $id);
            $skin->{skin_base} = $self->_make_skin_base($skin->{id},$skin->{skin_version}) if $skin;
            return $skin;
        }
    });
}

sub can_use_skin {
    my ($self,$skin) = @_;
    return unless defined $skin || $skin->{status};
    return $skin->{status} == Mixi::Skin::Config::SKIN_STATUS_DB->{CAN_OPEN} || $skin->{status} == Mixi::Skin::Config::SKIN_STATUS_DB->{CAN_OPEN_EDIT};
}

sub can_set_skin {
    my ($self,$skin) = @_;
    return unless defined $skin || $skin->{status} || $skin->{open_datetime} || $skin->{close_datetime};
    return ( $skin->{status} == Mixi::Skin::Config::SKIN_STATUS_DB->{CAN_OPEN} || $skin->{status} == Mixi::Skin::Config::SKIN_STATUS_DB->{CAN_OPEN_EDIT} ) && in_duration($skin->{open_datetime},$skin->{close_datetime});
}

sub _make_skin_base {
    my ($self,$id,$version) = @_;
    my $digest = Digest::HMAC_SHA1::hmac_sha1_hex( join( "_", $id, $version), Mixi::Skin::Config::PCSKIN_SECRET );
    return Mixi::Skin::Config::SKIN_BASE_PATH . "/" . $digest;
}

sub _get_editing_skin_version {
    my ($self,$skin_info) = @_;
    return unless $skin_info;

    my $obj;
    eval {
        my $engine  = Mixi::Convert->new('YAML');
        $obj = $engine->decode($skin_info);
    };
    if($@){
        Mixi::Log->new->warn("faild to convert yaml [$@]");
    }
    return unless $obj;
    return $obj->{skin_version};
}

sub is_skin_test_environment {
    return $ENV{SKIN_TEST_ENVIRONMENT};
}


1;

__END__

=pod

=encoding euc-jp

=head1 NAME

Mixi::Skin

=head1 SYNOPSIS

#IDを指定してミクコレ情報取得

    my $skin = Mixi::Skin->get_instance()->get_skin(id => $self->skin_id);

#SKINのオーナを指定してミクコレ情報取得
  
    if ($self->owner) {
        $skin = Mixi::Skin->get_instance()->get_member_skin(member_id => $self->owner->{id});
    }else{
        $skin = Mixi::Skin->get_instance()->get_member_skin(member_id => $self->member->{id});
    }

=head1 DESCRIPTION

PC/TOミクコレに必要な機能を提供するインタフェースクラス

=head1 MTHODS

=over

=item get_skin_css

    ミクコレに必要なcssのリストを返します。

=item get_public_skins

    公開可能なミクコレ一覧を返します。

=item get_public_genres

    公開可能なジャンル一覧を返します。

=item get_skin

    指定されたIDのミクコレ情報を返します。

=item get_member_skin

    指定されたMEMBER_IDのユーザが着用するミクコレ情報を返します。

=item set_member_skin

    指定されたSKINをMEMBER_IDのユーザに設定します。

=item delete_member_skin

    指定されたMEMBER_IDのユーザのミクコレ設定を解除します。

=back

=head1 AUTHOR

プロフィールユニット E<lt>unit-profile@mixi.co.jp<gt>

問い合わせはJIRA( http://jira.intra.mixi.co.jp/browse/PROFILE ) までお願いします。

= cut
