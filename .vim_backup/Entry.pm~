package Mixi::Weather::Entry;
use strict;
use warnings;

=encoding euc-jp

=head1 NAME

Mixi::Weather::Entry - 天気情報を扱うクラス

=head1 SYNOPSIS

    use Mixi::Weather::Entry;
    my $collection = Mixi::Weather::Entry->find_list_by_pref_id(
        pref_id => $pref_id,
    );

=head1 DESCRIPTION

天気情報を扱うクラス

=cut

use parent qw/Mixi::Weather::Model::Base/;

#::<<other>>
use Scalar::Util;

#::<<core library>>
use Nove::Core::Exception qw/throw/;
use Nove::Core::Assertion;

#::<<common library>>
use Mixi::Picture::Prefix;
use Nove::Core::Data::Structure qw/
    TYPE_UINT
    verify_required
/;

#::<<framework>>
use Mixi::Entity::Interface;

#::<<application>>
use Mixi::Weather::Pollen;
use Mixi::Weather::Format;
use Mixi::Weather::Collection;
use Mixi::Weather::Entry::Renderer;

#::CONSTANTS
use constant {
    WEATHER_STRING => {
        1 => {
            name      => '晴',
            code_name => 'sunny',
            emoji     => '[m:1]',
        },
        2 => {
            name      => '曇',
            code_name => 'cloudy',
            emoji     => '[m:2]',
        },
        3 => {
            name      => '雨',
            code_name => 'rainy',
            emoji     => '[m:3]',
        },
        4 => {
            name      => '雪',
            code_name => 'snowy',
            emoji     => '[m:4]',
        },
        8 => {
            name      => 'のち',
            code_name => 'then',
            emoji     => '→',
        },
        9 => {
            name      => '時々',
            code_name => 'partly',
            emoji     => '｜',
        },
    },
    WEATHER_NAME_DELIMITER      => '',
    WEATHER_CODE_NAME_DELIMITER => '_',
    # @KEY: weather:<PREF_ID>:common 都道府県の天気情報
    CACHE_KEY_WEATHER_LIST_BY_PREF_ID    => 'weather:%s:common',
    CACHE_EXPIRE_WEATHER_LIST_BY_PREF_ID => 60 * 60 * 24,
};

our @ACCESSORS_DB_PK = qw/pref_id date/;
our @ACCESSORS_DB_NON_PK = qw/
    weather temp_max temp_min
    pp pp_00_06 pp_06_12 pp_12_18 pp_18_24
    timestamp
/;
our @ACCESSORS = (@ACCESSORS_DB_NON_PK, qw/
    temp_max_diff temp_min_diff
    pollen_name pollen_code pollen_code_name
    renderer
/);
__PACKAGE__->mk_ro_accessors(@ACCESSORS_DB_PK);
__PACKAGE__->mk_accessors(@ACCESSORS);
__PACKAGE__->assert_implements(
    Mixi::Entity::Interface::methods_of(
        qw/IRenderable/
    )
);

# リクエストキャッシュを扱うプライベートパッケージ名のショートカット
sub __per_request_cache { __PACKAGE__ . '::' . '_PerRequestCache' }

=head1 CLASS METHODS

=head2 $entry = Mixi::Weather::Entry->lookup(pref_id => $pref_id, date => $date);

    一意の天気情報を取得する

    入力
        $pref_id: 都道府県ID
        $date:    日付(YYYY-MM-DD)
    
    出力
        $entry: Mixi::Weather::Entry インスタンス

    備考
        DBアクセスあり(memcached使用)

=cut

sub lookup {
    my $class = shift;
    my %args = @_;
    verify_required($args{pref_id}, TYPE_UINT);
    verify_required($args{date}, Mixi::Weather::Format::TYPE('WEATHER_DATE'));

    my $instance_map = $class->_get_weather_instance_map_by_pref_id(
        pref_id => $args{pref_id},
    );
    return if not $instance_map or not %$instance_map;
    return $instance_map->{$args{date}};
}

=head2 $weather_collection = Mixi::Weather::Entry->find_list_by_pref_id(pref_id => $pref_id);

    指定都道府県の天気情報を取得する

    入力
        $pref_id: 都道府県ID
    
    出力
        $weather_collection: Mixi::Weather::Entry インスタンスのコレクション

    備考
        DBアクセスあり(memcached使用)

=cut

sub find_list_by_pref_id {
    my $class = shift;
    my %args = @_;
    verify_required($args{pref_id}, TYPE_UINT);

    my $instance_map = $class->_get_weather_instance_map_by_pref_id(
        pref_id => $args{pref_id},
    );
    my @instances;
    if ($instance_map and %$instance_map) {
        for my $date (sort {$a cmp $b} keys %$instance_map) {
            push @instances, $instance_map->{$date};
        }
    }
    my $collection = Mixi::Weather::Collection->new(
        content    => \@instances,
        total_rows => scalar @instances,
        has_next   => 0,
        has_prev   => 0,
    );
    return $collection;
}

=head2 $rows = $class->set_all_weather_list_by_pref_id_to_memcached(pref_id => $pref_id);

    指定都道府県の天気情報を memcached にセットしつつ、セットしたデータを返します。

    入力
        $pref_id: 都道府県ID

    出力
        $rows: 指定都道府県の天気情報リスト

    備考
        DBアクセスあり
=cut

sub set_all_weather_list_by_pref_id_to_memcached {
    my $class = shift;
    my %args = @_;
    verify_required($args{pref_id}, TYPE_UINT);

    # 天気情報を取得
    my $db_s = $class->db(-Weather => {role => 's'});
    my $rows = $db_s->select_weather_list_by_pref_id(
        pref_id => $args{pref_id},
    );

    # 花粉情報を取得してマージ
    my %pollen_map;
    my $pollen_collection = Mixi::Weather::Pollen->find_list_by_pref_id(
        pref_id => $args{pref_id},
    );
    for my $pollen ($pollen_collection->array) {
        $pollen_map{$pollen->date} = $pollen;
    }
    for my $row (@$rows) {
        my $pollen = $pollen_map{$row->{date}};
        next if not $pollen;
        $row->{pollen_code}      = $pollen->pollen;
        $row->{pollen_code_name} = $pollen->get_pollen_code_name();
        $row->{pollen_name}      = $pollen->get_pollen_name();
    }

    my $memcached_key = sprintf(CACHE_KEY_WEATHER_LIST_BY_PREF_ID, $args{pref_id});
    my $memcached = $class->memcached();
    $memcached->set_all($memcached_key, $rows, CACHE_EXPIRE_WEATHER_LIST_BY_PREF_ID);

    return $rows;
}

=head2 $instance_map = $class->_get_weather_instance_map_by_pref_id(pref_id => $pref_id);

    天気インスタンスのpref_idマッピング情報(hashref)を取得する。
    リクエストキャッシュに無い場合は memcached から、memcached に無い場合は DB から取得し、
    それぞれのレイヤーでキャッシュして返します。

    入力
        $pref_id: 都道府県ID

    出力
        $instance_map: Mixi::Weather::Entry インスタンスを pref_id をキーにした HASHREF として返す

    備考
        DBアクセスあり(memcached使用)

=cut

sub _get_weather_instance_map_by_pref_id {
    my $class = shift;
    my %args = @_;
    verify_required($args{pref_id}, TYPE_UINT);

    my $request_cache_key = sprintf('weather_instance_map_by_pref_id:%s', $args{pref_id});
    my $instance_map = __per_request_cache->get($request_cache_key);
    if (not defined $instance_map) {
        $instance_map = {};
        my $rows = $class->__get_weather_list_by_pref_id_from_memcached(
            pref_id => $args{pref_id},
        );
        my ($prev_temp_max, $prev_temp_min);
        for my $row (@$rows) {
            # 前日との気温差を計算
            my $temp_max_diff = (defined $prev_temp_max and defined $row->{temp_max}) ? $row->{temp_max} - $prev_temp_max : undef;
            my $temp_min_diff = (defined $prev_temp_min and defined $row->{temp_min}) ? $row->{temp_min} - $prev_temp_min : undef;
            my $instance = $class->new(
                %$row,
                temp_max_diff => $temp_max_diff,
                temp_min_diff => $temp_min_diff,
            );
            $instance_map->{$instance->date} = $instance;
            $prev_temp_max = $row->{temp_max};
            $prev_temp_min = $row->{temp_min};
        }
        __per_request_cache->set($request_cache_key => $instance_map);
    }
    return $instance_map;
}

=head2 $rows = $class->__get_weather_list_by_pref_id_from_memcached(pref_id => $pref_id);

    指定都道府県の天気情報を memcached から取得する。
    ※memcachedにキャッシュデータが存在しない場合は取得して載せます。

    入力
        $pref_id: 都道府県ID

    出力
        $rows: 指定都道府県の天気情報リスト

    備考
        DBアクセスあり(memcached使用)

=cut

sub __get_weather_list_by_pref_id_from_memcached {
    my $class = shift;
    my %args = @_;
    verify_required($args{pref_id}, TYPE_UINT);

    my $memcached_key = sprintf(CACHE_KEY_WEATHER_LIST_BY_PREF_ID, $args{pref_id});
    my $memcached = $class->memcached();
    my $rows = $memcached->get($memcached_key);
    if (not defined $rows) {
        $rows = $class->set_all_weather_list_by_pref_id_to_memcached(
            pref_id => $args{pref_id},
        );
    }
    return $rows;
}

=head1 INSTANCE METHODS

=head2 $rendered_data = $self->render($context);

    出力用にインスタンスを加工して返す

    入力
        $context: Mixi::Entity::Context::Browsing インスタンス
    
    出力
        $rendered_data: Renderer によって加工されたデータ

    備考
        特になし

=cut

sub render {
    my $self = shift;
    my $context = shift;
    throw 'Invalid call: render() is not a class method.' if not Scalar::Util::blessed($self);
    $self->renderer(Mixi::Weather::Entry::Renderer->new) if not $self->renderer;
    return $self->renderer->render($self, $context);
}

=head2 $plain_object = $self->to_plain_object();

    インスタンスをプレーンオブジェクトに加工して返す

    入力
        無し
    
    出力
        $plain_object: 加工されたデータ

    備考
        特になし

=cut

sub to_plain_object {
    my $self = shift;
    throw 'Invalid call: to_plain_object() is not a class method.' if not Scalar::Util::blessed($self);
    return +{
        map {
            $_ => $self->$_
        } grep {
            $_ !~ m/renderer/
        } (@ACCESSORS_DB_PK, @ACCESSORS)
    };
}

=head2 $weather_code_name = $self->get_weather_code_name();

    天気を表すコード名を返す

    入力
        無し

    出力
        $weather_code_name: 天気コード名(「sunny_then_rainy」など)

    備考
        特になし

=cut

sub get_weather_code_name {
    my $self = shift;
    throw 'Invalid call: get_weather_code_name() is not a class method.' if not Scalar::Util::blessed($self);
    my @weather_codes = split //, $self->weather;
    my @weather_code_names = map {WEATHER_STRING->{$_}->{code_name}} @weather_codes;
    return join WEATHER_CODE_NAME_DELIMITER, @weather_code_names;
}

=head2 $weather_name = $self->get_weather_name();

    天気を表す名称を返す

    入力
        無し

    出力
        $weather_name: 天気名称(「晴のち雨」など)

    備考
        特になし

=cut

sub get_weather_name {
    my $self = shift;
    throw 'Invalid call: get_weather_name() is not a class method.' if not Scalar::Util::blessed($self);
    my @weather_codes = split //, $self->weather;
    my @weather_names = map {WEATHER_STRING->{$_}->{name}} @weather_codes;
    return join WEATHER_NAME_DELIMITER, @weather_names;
}

=head2 $weather_emoji = $self->get_weather_emoji();

    天気を表す絵文字を返す

    入力
        無し

    出力
        $weather_emoji: 絵文字変換用文字列(「[m:1]→[m:3]」など)

    備考
        特になし

=cut

sub get_weather_emoji {
    my $self = shift;
    throw 'Invalid call: get_weather_emoji() is not a class method.' if not Scalar::Util::blessed($self);
    my @weather_codes = split //, $self->weather;
    my @weather_emoji_list = map {WEATHER_STRING->{$_}->{emoji}} @weather_codes;
    return join '', @weather_emoji_list;
}

=head2 $weather_image_url = $self->get_weather_image_url();

    天気画像のURLを返す

    入力
        無し

    出力
        $weather_image_url: 天気画像のURL

    備考
        特になし

=cut

sub get_weather_image_url {
    my $self = shift;
    my %args = @_;
    throw 'Invalid call: get_weather_image_url() is not a class method.' if not Scalar::Util::blessed($self);
    return sprintf(
        '%s/img/basic/icon/i_wt%s.gif',
        Mixi::Picture::Prefix::get_img_mixi_prefix(),
        $self->weather
    );
}

=head1 PRIVATE PACKAGE

=head2 Mixi::Weather::Entry::_PerRequestCache

    天気情報のリクエスト単位でのキャッシュを扱うクラス

=cut

package Mixi::Weather::Entry::_PerRequestCache;
use strict;
use warnings;

use base qw/Nove::Core::Module::Singleton::PerRequest/;

sub set {
    my $class = shift;
    my ($key, $value) = @_;
    my $instance = $class->instance;
    $instance->{$key} = $value;
}

sub get {
    my $class = shift;
    my ($key) = @_;
    my $instance = $class->instance;
    return $instance->{$key};
}

1;
