use strict;
use warnings;
use utf8;

use Test::More;
use Test::Deep;

use Mixi::Test qw/require_utf8_output/;
use Mixi::Test::Fixtures -checker => 'strict';
use Nove::Test::Fixtures::Memcached;
use Mixi::Test::DataFactory qw(
    Mixi::Skin::Touch::SkinData
    Mixi::Skin::Touch::Purchase
);
use Mixi::Test::Mock::Service::Procedure;

BEGIN {
    use_ok 'Mixi::Skin::Touch::CPocket';
}

subtest 'get_skin_content_list_by_tag_id' => sub {
    my $member_id = 4444;

    my $skin_1 = Mixi::Test::DataFactory->make('Mixi::Skin::Touch::SkinData', {
        id           => 10001,
        skin_version => 2,
        content_id   => 20001,
    });
    my $skin_2 = Mixi::Test::DataFactory->make('Mixi::Skin::Touch::SkinData', {
        id           => 10002,
        skin_version => 3,
        content_id   => 20002,
    });
    Mixi::Test::DataFactory->make('Mixi::Skin::Touch::Purchase', {
        member_id  => $member_id,
        product_id => $skin_2->{id},
    });

    my $tag_id = 1234;

    my $content_1 = _content_1($skin_1->{content_id});
    my $content_2 = _content_2($skin_2->{content_id});
    my $content_9999 = _content_9999(987654321); # not exist in skin db

    my $procedure_mock = Mixi::Test::Mock::Service::Procedure->mock(
        internal => 'jp.mixi.cpocket.market.getContentListByTag',
        sub {
            my ($self, $params) = @_;
            is($self->requester_id, $member_id, 'requester_id should be passed correctly');
            cmp_deeply($params, {
                tag_ids        => [1234],
                application_id => ignore(),
                service_id     => ignore(),
                start_index    => 1,
                quantity       => 10,
            }, 'valid params should be passed to procedure');

            return {
                total_results => 3,
                has_next      => 0,
                has_prev      => 0,
                content_list  => [
                    $content_1,
                    $content_2,
                    $content_9999,
                ],
            }
        }
    );

    my $result = Mixi::Skin::Touch::CPocket->get_skin_content_list_by_tag_id(
        member_id => $member_id,
        tag_id    => $tag_id,
        offset    => 0,
        limit     => 10,
    );

    cmp_deeply(
        $result,
        {
            total_results => 3,
            has_next      => 0,
            has_prev      => 0,
            content_list  => [
                {
                    %$content_1,
                    skin_id                => $skin_1->{id},
                    skin_preview_img_url   => re("\Qhttp://\E.+\Q/preview001.jpg\E\$"),
                    skin_thumbnail_img_url => re("\Qhttp://\E.+\Q/thumbnail001.jpg\E\$"),
                },
                {
                    %$content_2,
                    skin_id                => $skin_2->{id},
                    skin_preview_img_url   => re("\Qhttp://\E.+\Q/preview001.jpg\E\$"),
                    skin_thumbnail_img_url => re("\Qhttp://\E.+\Q/thumbnail001.jpg\E\$"),
                    is_bought              => 1, # overridden by legacy purchase db
                },
                {
                    %$content_9999,
                    # img_urls not available
                },
            ]
        },
        'should return valid structure with skin data'
    );
};

subtest 'get_skin_content_list_by_app_id' => sub {
    my $member_id = 2222;

    my $skin_1 = Mixi::Test::DataFactory->make('Mixi::Skin::Touch::SkinData', {
        id           => 20001,
        skin_version => 2,
        content_id   => 30001,
    });
    my $skin_2 = Mixi::Test::DataFactory->make('Mixi::Skin::Touch::SkinData', {
        id           => 20002,
        skin_version => 1,
        content_id   => 30002,
    });
    Mixi::Test::DataFactory->make('Mixi::Skin::Touch::Purchase', {
        member_id  => $member_id,
        product_id => $skin_2->{id},
    });

    my $content_1 = _content_1($skin_1->{content_id});
    my $content_2 = _content_2($skin_2->{content_id});
    my $content_9999 = _content_9999(987654321); # not exist in skin db

    my $procedure_mock = Mixi::Test::Mock::Service::Procedure->mock(
        internal => 'jp.mixi.cpocket.store.getContentListByAppId',
        sub {
            my ($self, $params) = @_;
            is($self->requester_id, $member_id, 'requester_id should be passed correctly');
            cmp_deeply($params, {
                application_id => ignore(),
                service_id     => ignore(),
                start_index    => 1,
                count          => 10,
                order          => 'DESC',
                sort           => 'selling_begin_at',
            }, 'valid params should be passed to procedure');

            return {
                total_results => 3,
                has_next      => 0,
                has_prev      => 0,
                content_list  => [
                    $content_1,
                    $content_2,
                    $content_9999,
                ],
            }
        }
    );

    my $result = Mixi::Skin::Touch::CPocket->get_skin_content_list_by_app_id(
        member_id => $member_id,
        offset    => 0,
        limit     => 10,
        order     => 'DESC',
    );

    cmp_deeply(
        $result,
        {
            total_results => 3,
            has_next      => 0,
            has_prev      => 0,
            content_list  => [
                {
                    %$content_1,
                    skin_id                => $skin_1->{id},
                    skin_preview_img_url   => re("\Qhttp://\E.+\Q/preview001.jpg\E\$"),
                    skin_thumbnail_img_url => re("\Qhttp://\E.+\Q/thumbnail001.jpg\E\$"),
                },
                {
                    %$content_2,
                    skin_id                => $skin_2->{id},
                    skin_preview_img_url   => re("\Qhttp://\E.+\Q/preview001.jpg\E\$"),
                    skin_thumbnail_img_url => re("\Qhttp://\E.+\Q/thumbnail001.jpg\E\$"),
                    is_bought              => 1, # overridden by legacy purchase db
                },
                {
                    %$content_9999,
                    # skin data not available
                },
            ]
        },
        'should return valid structure with skin data'
    );
};

sub _content_1 {
    my $content_id = shift;
    {
        object_type  => "content_for_sale",
        content_id   => $content_id,
        content_name => "くまモンの夏休み",
        description  => "ゆるキャラくまモンの夏休みバージョンのミクコレです。",
        tags => [
            { id => "1234", name => "くまモン" },
            { id => "2222", name => "くまモンの夏休み" }
        ],
        provider  => { id => 111, name => "熊本県広報課" },
        copyright => "(c)2010熊本県くまモン#99999",
        price     => 105,
        selling_begin_at => "2013-01-30 23:59:59",
        selling_end_at   => "2013-09-30 23:59:59",
        use_by  => "2013-12-31 23:59:59",
        has_stock_limit => 0,
        consumable_type => "nonconsumable",
        is_bought => 0,
    }
}

sub _content_2 {
    my $content_id = shift;
    {
        object_type  => "content_for_sale",
        content_id   => $content_id,
        content_name => "content2",
        description  => "",
        tags => [
            { id => "1234", name => "くまモン" },
        ],
        provider  => { id => 111, name => "熊本県広報課" },
        copyright => "(c)2010熊本県くまモン#99999",
        price     => 105,
        selling_begin_at => "2013-01-30 23:59:59",
        selling_end_at   => "2013-09-30 23:59:59",
        use_by  => "2013-12-31 23:59:59",
        has_stock_limit => 0,
        consumable_type => "nonconsumable",
        is_bought => 0,
    }
}

sub _content_9999 {
    my $content_id = shift;
    {
        object_type  => "content_for_sale",
        content_id   => $content_id,
        content_name => "content_idないやつ用",
        description  => "",
        tags => [
            { id => "1234", name => "くまモン" },
        ],
        provider  => { id => 111, name => "熊本県広報課" },
        copyright => "(c)2010熊本県くまモン#99999",
        price     => 105,
        selling_begin_at => "2013-01-30 23:59:59",
        selling_end_at   => "2013-09-30 23:59:59",
        use_by  => "2013-12-31 23:59:59",
        has_stock_limit => 0,
        consumable_type => "nonconsumable",
        is_bought => 0,
    }
}

done_testing;
