use strict;
use warnings;
use Test::More;
use Test::Exception;
use Test::Deep;
use Test::MockObject::Extends;
use Mixi::Test;
use Mixi::Test::Fixtures -checker => 'strict', qw/DB_TOUCHSKIN/;
use Nove::Test::Fixtures::Memcached;

BEGIN {
    use_ok 'Mixi::Skin::Touch';
}
use Mixi::Skin::Touch::Config;

my $memcached = Nove::Test::Fixtures::Memcached->memcached_instance;

my $f = Mixi::Test::Fixtures->get_fixture_object('DB_TOUCHSKIN');

sub _skin {
    my $obj = shift;
    superhashof({
        id                       => $obj->{id},
        name                     => $obj->{name},
        skin_type                => $obj->{skin_type},
        skin_version             => $obj->{skin_version},
        content_id               => $obj->{content_id},
        open_datetime            => $obj->{open_datetime},
        skin_base                => ignore(),
        # TODO
        has_home_header_img      => ignore(),
        has_prof_header_img      => ignore(),
        has_bg_img               => ignore(),
        has_contents_title_img   => ignore(),
        has_logo_jack            => ignore(),
        has_banner_img           => ignore(),
        banner_link              => ignore(),
        basic_text_color         => ignore(),
        strong_text_color        => ignore(),
        weak_text_color          => ignore(),
        weaker_text_color        => ignore(),
        link_color               => ignore(),
        strong_link_color        => ignore(),
        border_color             => ignore(),
        background_color         => ignore(),
        partial_background_color => ignore(),
        contents_title_bg_color  => ignore(),
        gradation_start_color    => ignore(),
        gradation_end_color      => ignore(),
    })
}

subtest 'get_skin' => sub {

    subtest 'in production environment' => sub {
        my $s = Mixi::Skin::Touch->new;

        my $skin = $s->get_skin(id => 0);
        is($skin, undef, '0が与えられた場合はundef');

        $skin = $s->get_skin(id => 99999);
        is($skin, undef, '存在しないレコードの場合はundef');

        dies_ok { $skin = $s->get_skin(id => 'hogehoge') } '数字以外を渡すと死ぬ';

        dies_ok { $skin = $s->get_skin(id => '') } '空文字を渡すと死ぬ';

        dies_ok { $skin = $s->get_skin(id => undef) } 'undefを渡すと死ぬ';

        $skin = $s->get_skin(id => $f->registration_test->{id});
        is($skin, undef, '登録中のミクコレは取得不可');

        $skin = $s->get_skin(id => $f->force_closed_test->{id});
        is($skin, undef, '強制終了のミクコレは取得不可');

        my $memcached_key_open_edit = 'touch_skin:skin_data:'.$f->open_edit_test->{id};
        fail if defined $memcached->{$memcached_key_open_edit};
        $skin = $s->get_skin(id => $f->open_edit_test->{id});
        cmp_deeply($skin, _skin($f->open_edit_test), '公開中修正のミクコレは取得可');
        ok($memcached->{$memcached_key_open_edit}, 'memcachedにセットされたか');

        my $memcached_key_open = 'touch_skin:skin_data:'.$f->open_test->{id};
        fail if defined $memcached->{$memcached_key_open};
        $skin = $s->get_skin(id => $f->open_test->{id});
        cmp_deeply($skin, _skin($f->open_test), '公開中のミクコレは取得可');
        ok($memcached->{$memcached_key_open}, 'memcachedにセットされたか');

        is(
            $s->_make_skin_base($f->open_test->{id},$f->open_test->{skin_version}),
            $skin->{skin_base},
            'get_skinでちゃんと_make_skin_baseをよんでるか'
        );
    };

    subtest 'in staging environment' => sub {

        subtest 'for CAN_OPEN_EDIT skin' => sub {
            my $s = Mixi::Skin::Touch->new;
            my $mock_obj = Test::MockObject::Extends->new($s);
            $mock_obj->set_true('is_skin_test_environment');
            $mock_obj->mock(get_staging_skin => sub {
                my ($self, $id) = @_;
                is($id, 1234, '正しいミクコレIDが渡る');
                return {
                    this_is => 'mocked_skin_info',
                    status  => Mixi::Skin::Touch::Config::SKIN_STATUS_DB->{CAN_OPEN_EDIT},
                };
            });

            is_deeply(scalar ($mock_obj->get_skin(id => 1234)),
                {
                    this_is => 'mocked_skin_info',
                    status  => Mixi::Skin::Touch::Config::SKIN_STATUS_DB->{CAN_OPEN_EDIT},
                },
                'ステージング用のスキン情報を返却する'
            );
        };

        subtest 'for FORCE_CLOSED skin' => sub {
            my $s = Mixi::Skin::Touch->new;
            my $mock_obj = Test::MockObject::Extends->new($s);
            $mock_obj->set_true('is_skin_test_environment');
            $mock_obj->mock(get_staging_skin => sub {
                my ($self, $id) = @_;
                is($id, 1234, '正しいミクコレIDが渡る');
                return {
                    this_is => 'mocked_skin_info',
                    status  => Mixi::Skin::Touch::Config::SKIN_STATUS_DB->{FORCE_CLOSED},
                };
            });

            is(scalar ($mock_obj->get_skin(id => 1234)), undef, '何も返さない');
        };

        subtest 'for REGISTRATION skin' => sub {
            my $s = Mixi::Skin::Touch->new;
            my $mock_obj = Test::MockObject::Extends->new($s);
            $mock_obj->set_true('is_skin_test_environment');
            $mock_obj->mock(get_staging_skin => sub {
                my ($self, $id) = @_;
                is($id, 1234, '正しいミクコレIDが渡る');
                return {
                    this_is => 'mocked_skin_info',
                    status  => Mixi::Skin::Touch::Config::SKIN_STATUS_DB->{REGISTRATION},
                };
            });

            is_deeply(
                scalar($mock_obj->get_skin(id => 1234)),
                {
                    this_is => 'mocked_skin_info',
                    status  => Mixi::Skin::Touch::Config::SKIN_STATUS_DB->{REGISTRATION},
                },
                '登録中のスキン情報を返却する'
            );
        };
    };

};

sub _public_skin {
    my $obj = shift;
    {
        id            => $obj->{id},
        name          => $obj->{name},
        skin_type     => $obj->{skin_type},
        skin_version  => $obj->{skin_version},
        content_id    => $obj->{content_id},
        open_datetime => $obj->{open_datetime},
        skin_base     => ignore(),
    }
}

subtest 'get_public_skins_by_skin_type' => sub {

    my $s = Mixi::Skin::Touch->new;
    my $result = $s->get_public_skins_by_skin_type(
        skin_type => Mixi::Skin::Touch::Config::SKIN_TYPE->{SIMPLE},
    );
    my $count = $result->{count};
    my $skins = $result->{rows};
    is($count, 3, '公開中の無料ミクコレは3個ある');

    cmp_deeply($skins,
        [
            _public_skin($f->open_test2),
            _public_skin($f->open_test),
            _public_skin($f->open_edit_test),
        ],
        '正しいミクコレ情報が返却されているか'
    );

};

subtest 'get_public_skins_by_genre_and_skin_type' => sub {

    my $s = Mixi::Skin::Touch->new;
    my $result = $s->get_public_skins_by_genre_and_skin_type(
        genre_id => 1,
        skin_type => Mixi::Skin::Touch::Config::SKIN_TYPE->{SIMPLE},
    );
    my $count = $result->{count};
    my $skins = $result->{rows};
    is($count, 2, 'genre_idが1の場合はミクコレは2個ある');

    cmp_deeply($skins,
        [
            _public_skin($f->open_test),
            _public_skin($f->open_edit_test),
        ],
        '正しいミクコレ情報が返却されているか'

    );

};

subtest 'get_public_skins' => sub {

    my $s = Mixi::Skin::Touch->new;
    my $result = $s->get_public_skins();
    my $count = $result->{count};
    my $skins = $result->{rows};
    is($count, 5, '公開中のミクコレは5個ある');

    cmp_deeply($skins,
        [
            _public_skin($f->deluxe_open_test),
            _public_skin($f->open_test2),
            _public_skin($f->open_test),
            _public_skin($f->open_edit_test),
            _public_skin($f->tieup_banner_test),
        ],
        '正しいミクコレ情報が返却されているか'
    );
};

subtest 'get_public_skins_by_genre' => sub {

    my $s = Mixi::Skin::Touch->new;
    my $result = $s->get_public_skins_by_genre(genre_id => $f->test_genre2->{id});
    my $count = $result->{count};
    my $skins = $result->{rows};
    is($count, 2, 'ジャンル内で公開中のミクコレは2個ある');

    cmp_deeply($skins,
        [
            _public_skin($f->deluxe_open_test),
            _public_skin($f->open_test),
        ],
        '正しいミクコレ情報が返却されているか'
    );

};

subtest 'get_skins_by_content_ids' => sub {

    my $s = Mixi::Skin::Touch->new;
    my $skins = $s->get_skins_by_content_ids(
        content_ids  => [$f->open_test->{content_id}, $f->open_test2->{content_id}],
    );

    cmp_deeply($skins,
        [
            _public_skin($f->open_test2),
            _public_skin($f->open_test),
        ],
        '正しいミクコレ情報が返却されているか'
    );

};
subtest 'get_member_skin' => sub {

    my $memcached_key1 = 'touch_skin:member_skin:'.$f->test_member1->{member_id};
    fail if defined $memcached->{$memcached_key1};

    my $s = Mixi::Skin::Touch->new;
    my $skin = $s->get_member_skin(member_id => $f->test_member1->{member_id});
    is($skin->{id}, 4, '正しいミクコレが返却されているか');
    is($memcached->{$memcached_key1}, 4, 'memcachedにミクコレIDが入っているか');

    my $memcached_key2 = 'touch_skin:member_skin:1234567890';
    fail if defined $memcached->{$memcached_key2};

    $skin = $s->get_member_skin(member_id => 1234567890);
    is($skin, undef, '設定されていない場合はundef');
    is($memcached->{$memcached_key2}, 0, 'memcachedに未設定値0が入っているか');

    $skin = $s->get_member_skin(member_id => 0);
    is($skin, undef, 'member_idが0の場合はundef');

    dies_ok { $skin = $s->get_member_skin(member_id => 'hogehoge') } '数字以外を渡すと死ぬ';

};

done_testing;
