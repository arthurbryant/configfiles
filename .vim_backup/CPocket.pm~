package Mixi::Skin::Touch::CPocket;

use strict;
use warnings;
use utf8;

#::<<other>>
use Params::Validate;

#::<<common library>>
use Mixi;

#::<<core library>>
use Nove::Core::Log;
use Nove::Core::Net::IPAddress qw/get_ip_address/;
use Nove::Core::Cache::Memcached::Wrap qw/use_memcached/;

#::<<service>>
use Mixi::Service::Procedure::InternalGateway;

#::<<application>>
use Mixi::Skin::Touch;
use Mixi::Skin::Touch::Purchase;
use Mixi::Skin::Touch::Config qw/CACHE/;

=encoding utf8

=head1 NAME

 Mixi::Skin::Touch::CPocket touchミクコレ

=head1 DESCRIPTION

 touch版ミクコレ cpocketのプロシージャとミクコレ側のモジュール使用しミクコレのデータを取得

=cut

=head1 METHODS
 get_skin_content_list_by_tag_id
 get_skin_content_by_skin_id
 get_skin_content_by_content_id
 get_skin_contents_list_by_content_ids
 get_skin_content_list_by_app_id
 get_paid_skin_content_list
 set_member_skin_by_content_id
 get_member_skin
 can_use_skin_by_content_id

=cut

#::CONSTANTS
use constant {
    APPLICATION_ID => {
        DEBUG      => 'jp.mixi.dev.touch',
        STAGING    => 'jp.mixi.touch.stage.76bdc67a2d',
        PRODUCTION => 'jp.mixi.touch.8ee6e2544f',
    },
    SERVICE_ID     => {
        DEBUG      => 12,
        PRODUCTION => undef,
    },
    OFFSET2START_INDEX => 1,
};

=head2 $result = Mixi::Skin::Touch::CPocket->get_skin_content_list_by_tag_id(%args);

 tag_idからミクコレの一覧を取得

 INPUT
    member_id
    tag_id
    offset
    limit

 OUTPUT
  成功時：ミクコレデータのリスト
  失敗時：undef

=cut

sub get_skin_content_list_by_tag_id {
    my $class  = shift;
    my %params = Params::Validate::validate(@_, {
        member_id => { type => Params::Validate::SCALAR, regex => qr/\A\d+\z/, },
        tag_id    => { type => Params::Validate::SCALAR, regex => qr/\A\d+\z/, },
        offset    => { optional => 1, default  => 0, },
        limit     => { optional => 1, defalut  => 10, },
    });

    my $content_list_response = $class->_get_content_list_by_tag_id(
        requester_id => $params{member_id},
        tag_id       => $params{tag_id},
        start_index  => $params{offset} + OFFSET2START_INDEX,
        count => $params{limit},
    );
    return unless $content_list_response;

    $class->_assign_skin_data($content_list_response);
    $class->_assign_is_bought_legacy($content_list_response, $params{member_id});

    return $content_list_response;
}

sub _get_content_list_by_tag_id {
    my ($class, %args) = @_;
    return Mixi::Service::Procedure::InternalGateway->call(
        'jp.mixi.cpocket.market.getContentListByTag', {
            requester_id => $args{requester_id},
            params => {
                tag_ids        => [$args{tag_id}],
                service_id     => __get_service_id(),
                application_id => __get_application_id(),
                start_index    => $args{start_index},
                count => $args{count},
            },
        }
    );
}

=head2 Mixi::Skin::Touch::CPocket->get_skin_content_by_skin_id {

 skin_idからミクコレの情報を取得

 INPUT
   member_id
   skin_id

 OUTPUT
   成功時:ミクコレのデータ
   失敗時:undef

=cut

sub get_skin_content_by_skin_id {
    my $class  = shift;
    my %params = Params::Validate::validate(@_, {
        member_id => { type => Params::Validate::SCALAR, regex => qr/\A\d+\z/, },
        skin_id   => { type => Params::Validate::SCALAR, regex => qr/\A\d+\z/, },
    });

    my $skin = Mixi::Skin::Touch->new->get_skin(
        id => $params{skin_id},
    );
    return unless $skin;

    return unless $skin->{content_id};
    my $content_response = $class->_get_content_list_by_content_ids (
        requester_id => $params{member_id},
        content_ids  => [$skin->{content_id}],
    );
    unless ($content_response && $content_response->{total_results}) {
        Nove::Core::Log->warn("skin_id [$skin->{id}]: content_id [$skin->{content_id}] is not exist in CPocket");
        return;
    }

    $class->_assign_skin_data($content_response, { $skin->{content_id} => $skin });
    $class->_assign_is_bought_legacy($content_response, $params{member_id});

    return $content_response->{content_list}->[0];
}

=head2 $result = Mixi::Skin::Touch::CPocket->get_skin_content_by_content_id {

 content_idからミクコレの情報を取得

 INPUT
   member_id
   content_id

 OUTPUT
   成功時:ミクコレのデータ
   失敗時:undef

=cut

sub get_skin_content_by_content_id {
    my $class  = shift;
    my %params = Params::Validate::validate(@_, {
        member_id  => { type => Params::Validate::SCALAR, regex => qr/\A\d+\z/, },
        content_id => { type => Params::Validate::SCALAR, regex => qr/\A\d+\z/, },
    });

    my $contents = $class->get_skin_contents_by_content_ids(
        member_id   => $params{member_id},
        content_ids => [$params{content_id}],
    );
    return unless $contents && $contents->[0];

    return $contents->[0];
}

=head2 get_skin_contents_list_by_content_ids

 content_idの配列からミクコレの情報を取得
 content_idsとOUTPUTの順序は同じになるよう保証されています
 対応するコンテンツが見つからないcontent_idに対しては何も返しません

 INPUT
   member_id
   content_ids

 OUTPUT
   成功時:ミクコレのデータが入った配列
   失敗時:undef

=cut

sub get_skin_contents_by_content_ids {
    my $class  = shift;
    my %params = Params::Validate::validate(@_, {
        member_id   => { type => Params::Validate::SCALAR, regex => qr/\A\d+\z/, },
        content_ids => { type => Params::Validate::ARRAYREF },
    });

    my $content_list_response = $class->_get_content_list_by_content_ids(
        requester_id => $params{member_id},
        content_ids  => $params{content_ids},
    );
    return unless $content_list_response;

    $class->_assign_skin_data($content_list_response);
    $class->_assign_is_bought_legacy($content_list_response, $params{member_id});

    # sort
    my %content_list_map = map {
        ($_->{content_id} => $_)
    } @{$content_list_response->{content_list}};
    return [
        map { $content_list_map{$_} || () } @{$params{content_ids}}
    ];
}

sub _get_content_list_by_content_ids {
    my ($class, %args) = @_;
    return Mixi::Service::Procedure::InternalGateway->call(
        'jp.mixi.cpocket.store.getContentListByContentId', {
            requester_id => $args{requester_id},
            params => {
                service_id     => __get_service_id(),
                application_id => __get_application_id(),
                content_ids    => $args{content_ids},
            },
        }
    );
}

=head2 $result = Mixi::Skin::Touch::CPocket->get_skin_content_list_by_app_id {

 app_idからミクコレの情報を取得

 INPUT
   service_id
   application_id

 OUTPUT
   成功時:ミクコレのデータのリスト
   失敗時:undef

=cut

sub get_skin_content_list_by_app_id {
    my $class = shift;

    my %params = Params::Validate::validate(@_, {
        member_id => { type => Params::Validate::SCALAR, regex => qr/\A\d+\z/, },
        offset    => { optional => 1, default => 0, },
        limit     => { optional => 1, defalut => 10, },
        order     => { optional => 1, default => 'DESC', },
        sort      => { optional => 1, default => 'selling_begin_at', },
    });

    my $content_list_response = $class->_get_content_list_by_app_id(
        requester_id => $params{member_id},
        start_index  => $params{offset} + OFFSET2START_INDEX,
        count        => $params{limit},
        order        => $params{order},
        sort         => $params{sort},
    );
    return unless $content_list_response;

    $class->_assign_skin_data($content_list_response);
    $class->_assign_is_bought_legacy($content_list_response, $params{member_id});

    return $content_list_response;
}

sub _get_content_list_by_app_id {
    my ($class, %args) = @_;
    return Mixi::Service::Procedure::InternalGateway->call(
        'jp.mixi.cpocket.store.getContentListByAppId', {
            requester_id => $args{requester_id},
            params => {
                service_id     => __get_service_id(),
                application_id => __get_application_id(),
                start_index    => $args{start_index},
                count          => $args{count},
                order          => $args{order},
                sort           => $args{sort},
            },
        }
    );
}

=head2 get_paid_skin_content_list

 購入済みのミクコレの情報を取得

 OUTPUT
   成功時:ミクコレのデータのリスト
   失敗時:undef

=cut

sub get_paid_skin_content_list {
    my $class = shift;

    my %params = Params::Validate::validate(@_, {
        member_id => { type => Params::Validate::SCALAR, regex => qr/\A\d+\z/, },
        offset    => { optional => 1, default => 0, },
        limit     => { optional => 1, defalut => 10, },
    });

    my $content_list_response = $class->_get_content_list_accessibility_by_app_id(
        requester_id    => $params{member_id},
        start_index     => $params{offset} + OFFSET2START_INDEX,
        count           => $params{limit},
        distribute_type => 'owned',
    );
    return unless $content_list_response;
    $class->_assign_skin_data($content_list_response);

    return $content_list_response;
}

sub _get_content_list_accessibility_by_app_id {
    my ($class, %args) = @_;
    return Mixi::Service::Procedure::InternalGateway->call(
        'jp.mixi.cpocket.accessibility.getContentListByAppId', {
            requester_id => $args{requester_id},
            params => {
                service_id      => __get_service_id(),
                application_id  => __get_application_id(),
                start_index     => $args{start_index},
                count           => $args{count},
                distribute_type => $args{distribute_type},
            },
        }
    );
}

=head2 set_member_skin_by_contnt_id

 ミクコレを設定する

 INPUT
   member_id
   content_id

 OUTPUT
   成功時: 1
   失敗時: 0

=cut
limit
sub set_member_skin_by_content_id {
    my $class = shift;

    my %params = Params::Validate::validate(@_, {
        member_id  => { type => Params::Validate::SCALAR, regex => qr/\A\d+\z/, },
        content_id => { type => Params::Validate::SCALAR, regex => qr/\A\d+\z/, },
    });

    my $skin = Mixi::Skin::Touch->new->get_skin_by_content_id(
        content_id => $params{content_id}
    );
    return unless $skin;

    return unless $class->can_use_skin_by_content_id(
        owner_id   => $params{member_id},
        content_id => $params{content_id},
        _skin      => $skin,
    );

    return Mixi::Skin::Touch->new->set_member_skin(
        member_id => $params{member_id},
        skin      => $skin,
    );
}

=head2 get_member_skin

 着用中のskin情報を取得する

 INPUT
   member_id

 OUTPUT
   成功時：skin情報のhashref
   失敗時：undef

=cut

sub get_member_skin {
    my $clss = shift;

    my %params = Params::Validate::validate(@_, {
        member_id   => { type => Params::Validate::SCALAR, regex => qr/\A\d+\z/, },
    });

    my $skin_module = Mixi::Skin::Touch->new;
    my $skin = $skin_module->get_member_skin(
        member_id => $params{member_id},
    );
    return unless $skin;

    my $image_url_data = $skin_module->get_image_url_data($skin, [qw/thumbnail/]);
    @$skin{keys %$image_url_data} = values %$image_url_data;

    return $skin;

}

=head2 can_use_skin_by_content_id

 owner_idがミクコレを使用可能かチェックする

 INPUT
   owner_id
   content_id

 OUTPUT
   利用可能: 1
   利用不可: 0

=cut

sub can_use_skin_by_content_id {
    my $class = shift;

    my %params = Params::Validate::validate(@_, {
        owner_id   => { type => Params::Validate::SCALAR, regex => qr/\A\d+\z/, },
        content_id => { type => Params::Validate::SCALAR, regex => qr/\A\d+\z/, },
        _skin      => { type => Params::Validate::HASHREF, optional => 1, }, # TODO: for legacy db
    });

    my $skin = $params{_skin};
    $skin ||= Mixi::Skin::Touch->new->get_skin_by_content_id( # TODO: should be cached
        content_id => $params{content_id}
    );
    return 0 unless $skin;

    my $status = $class->_get_display_status(
        owner_id   => $params{owner_id},
        content_id => $params{content_id},
    );
    return 0 unless $status;

    unless (DEBUG()) {
        return 0 if ($status->{is_only_domestic} && !$class->_is_from_domestic_ip);
    }

    return 1 if ($status->{can_display});

    # Legacy Purchase DB fallback
    return 1 if $class->_can_use_skin_legacy(
        member_id => $params{owner_id},
        skin      => $skin,
    );

    return 0;
};

sub _get_display_status {
    my ($class, %args) = @_;
    my $status_response = Mixi::Service::Procedure::InternalGateway->call(
        'jp.mixi.cpocket.accessibility.getDisplayStatus', {
            params => {
                owner_id       => $args{owner_id},
                application_id => __get_application_id(),
                content_ids    => [$args{content_id}],
            },
        }
    );
    return unless $status_response && $status_response->{list}->[0];
    return $status_response->{list}->[0];
}

sub _is_from_domestic_ip {
    my ($class) = @_;
    return Mixi::Service::Procedure::InternalGateway->call(
        'jp.mixi.net.ipaddress.isJapaneseIp', {
            params => {
                ip_addr => get_ip_address(),
            },
        }
    );
}

# TODO: remove later
sub _can_use_skin_legacy {
    my ($class, %args) = @_;
    my $member_id = $args{member_id};
    my $skin      = $args{skin};
    return 0 unless $member_id && $skin;

    return 1 if $skin->{skin_type} == Mixi::Skin::Touch::Config::SKIN_TYPE->{SIMPLE};
    return $class->_is_purchased_skin_legacy(
        member_id => $member_id,
        skin_id   => $skin->{id},
    );
}

# TODO: remove later
sub _is_purchased_skin_legacy {
    my ($class, %args) = @_;
    return 0 unless $args{member_id} && $args{skin_id};
    return Mixi::Skin::Touch::Purchase->get_purchase_info_by_member_id_and_product_id(
        member_id  => $args{member_id},
        product_id => $args{skin_id},
    ) ? 1 : 0;
}


sub _assign_skin_data {
    my ($class, $content_list_response, $skin_map) = @_;
    return unless($content_list_response->{total_results});

    my $skin_module = Mixi::Skin::Touch->new;

    my @content_ids = map {$_->{content_id}} @{$content_list_response->{content_list}};
    $skin_map ||= $skin_module->get_skin_map_by_content_ids(content_ids => \@content_ids);

    for my $content (@{ $content_list_response->{content_list} }) {
        my $skin = $skin_map->{$content->{content_id}};
        unless ($skin) {
            Nove::Core::Log->warn("content_id [$content->{content_id}] is not exist in skin db");
            next;
        }
        $content->{skin_id} = $skin->{id};
        my $image_url_data = $skin_module->get_image_url_data($skin, [qw/thumbnail preview/]);
        @$content{keys %$image_url_data} = values %$image_url_data;
    }
}

# TODO remove later
sub _assign_is_bought_legacy {
    my ($class, $content_list_response, $member_id) = @_;

    for my $content (@{$content_list_response->{content_list}}){
        $content->{is_bought} ||= $class->_is_purchased_skin_legacy(
            member_id => $member_id,
            skin_id   => $content->{skin_id}
        );
    }
}

sub __get_application_id {
    DEBUG()   ? APPLICATION_ID->{DEBUG}   :
    STAGING() ? APPLICATION_ID->{STAGING} :
    APPLICATION_ID->{PRODUCTION}
}

sub __get_service_id {
    DEBUG() ? SERVICE_ID->{DEBUG} :
    SERVICE_ID->{PRODUCTION}
}

1;
