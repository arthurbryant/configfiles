package Mixi::Skin::Touch::CPocket;

use strict;
use warnings;
use utf8;

#::<<other>>
use Params::Validate;

#::<<core library>>
use Nove::Core::Log;

#::<<service>>
use Mixi::Service::Procedure::InternalGateway;

#::<<application>>
use Mixi::Skin::Touch;
use Mixi::Skin::Touch::Purchase;
use Mixi::Skin::Touch::Config;

=encoding utf8

=head1 NAME

 Mixi::Skin::Touch::CPocket touchミクコレ

=head1 DESCRIPTION

 touch版ミクコレ cpocketのプロシージャとミクコレ側のモジュール使用しミクコレのデータを取得

=cut

=head1 METHODS

 get_skin_content_list_by_tag_id
 get_skin_content_by_content_id
 get_skin_content_list_by_app_id
 get_paid_skin_content_list
 set_member_skin_by_content_id
 get_display_status_by_content_id

=cut

#::CONSTANTS
use constant {
    APPLICATION_ID => 'jp.mixi.dev.touch',
    SERVICE_ID => 12,
    OFFSET2START_INDEX => 1,
};

=head2 $result = Mixi::Skin::Touch::CPocket->get_skin_content_list_by_tag_id(%args);

 tag_idからミクコレの一覧を取得

 INPUT
    member_id
    tag_id
    offset
    limit

 OUTPUT
  成功時：ミクコレデータのリスト
  失敗時：undef

=cut

sub get_skin_content_list_by_tag_id {
    my $class  = shift;
    my %params = Params::Validate::validate(@_, {
        member_id => { type => Params::Validate::SCALAR, regex => qr/\A\d+\z/, },
        tag_id    => { type => Params::Validate::SCALAR, regex => qr/\A\d+\z/, },
        offset    => { optional => 1, default  => 0, },
        limit     => { optional => 1, defalut  => 10, },
    });

    my $content_list_response = _get_content_list_by_tag_id(
        requester_id => $params{member_id},
        tag_id       => $params{tag_id},
        start_index  => $params{offset} + OFFSET2START_INDEX,
        quantity     => $params{limit},
    );
    return unless $content_list_response;
    _set_skin_data($content_list_response);
    return $content_list_response;
}

sub _get_content_list_by_tag_id {
    my %args = @_;
    return Mixi::Service::Procedure::InternalGateway->call(
        'jp.mixi.cpocket.market.getContentListByTag', {
            requester_id => $args{requester_id},
            params => {
                tag_ids        => [$args{tag_id}],
                application_id => APPLICATION_ID,
                service_id     => SERVICE_ID,
                start_index    => $args{start_index},
                quantity       => $args{quantity},
            },
        }
    );
}

=head2 Mixi::Skin::Touch::CPocket->get_skin_content_by_skin_id {

 skin_idからミクコレの情報を取得

 INPUT
   member_id
   skin_id

 OUTPUT
   成功時:ミクコレのデータ
   失敗時:undef

=cut

sub get_skin_content_by_skin_id {
    my $class  = shift;
    my %params = Params::Validate::validate(@_, {
        member_id => { type => Params::Validate::SCALAR, regex => qr/\A\d+\z/, },
        skin_id   => { type => Params::Validate::SCALAR, regex => qr/\A\d+\z/, },
    });

    my $skin = Mixi::Skin::Touch->new->get_skin(
        id => $params{skin_id},
    );
    return unless $skin;

    return unless $skin->{content_id};
    my $content_response = _get_content_by_content_id (
        requester_id => $params{member_id},
        content_id   => $skin->{content_id},
    );
    unless ($content_response) {
        Nove::Core::Log->warn("skin_id [$skin->{id}]: content_id [$skin->{content_id}] is not exist in CPocket");
        return;
    }
    _set_skin_data($content_response, [$skin]);

    return $content_response;
}

=head2 $result = Mixi::Skin::Touch::CPocket->get_skin_content_by_content_id {

 content_idからミクコレの情報を取得

 INPUT
   member_id
   content_id

 OUTPUT
   成功時:ミクコレのデータ
   失敗時:undef

=cut

sub get_skin_content_by_content_id {
    my $class  = shift;
    my %params = Params::Validate::validate(@_, {
        member_id  => { type => Params::Validate::SCALAR, regex => qr/\A\d+\z/, },
        content_id => { type => Params::Validate::SCALAR, regex => qr/\A\d+\z/, },
    });

    my $content_response = _get_content_by_content_id (
        requester_id => $params{member_id},
        content_id   => $params{content_id},
    );
    return unless $content_response;
    _set_skin_data($content_response);

    return $content_response;
}

sub _get_content_by_content_id {
    my %args = @_;
    return Mixi::Service::Procedure::InternalGateway->call(
        'jp.mixi.cpocket.store.getContentListByContentId', {
            requester_id => $args{requester_id},
            params => {
                service_id     => SERVICE_ID,
                application_id => APPLICATION_ID,
                content_ids    => [$args{content_id}],
            },
        }
    );
}

=head2 $result = Mixi::Skin::Touch::CPocket->get_skin_content_list_by_app_id {

 app_idからミクコレの情報を取得

 INPUT
   service_id
   application_id

 OUTPUT
   成功時:ミクコレのデータのリスト
   失敗時:undef

=cut

sub get_skin_content_list_by_app_id {
    my $class = shift;

    my %params = Params::Validate::validate(@_, {
        member_id => { type => Params::Validate::SCALAR, regex => qr/\A\d+\z/, },
        offset    => { optional => 1, default => 0, },
        limit     => { optional => 1, defalut => 10, },
        order     => { optional => 1, default => 'DESC', },
        sort      => { optional => 1, default => 'selling_begin_at', },
    });

    my $content_list_response = _get_content_list_by_app_id(
        requester_id => $params{member_id},
        start_index  => $params{offset} + OFFSET2START_INDEX,
        count        => $params{limit},
        order        => $params{order},
        sort         => $params{sort},
    );
    return unless $content_list_response;
    _set_skin_data($content_list_response);

    return $content_list_response;
}

sub _get_content_list_by_app_id {
    my %args = @_;
    return Mixi::Service::Procedure::InternalGateway->call(
        'jp.mixi.cpocket.store.getContentListByAppId', {
            requester_id => $args{requester_id},
            params => {
                service_id     => SERVICE_ID,
                application_id => APPLICATION_ID,
                start_index    => $args{start_index},
                count          => $args{count},
                order          => $args{order},
                sort           => $args{sort},
            },
        }
    );
}

=head2 get_paid_skin_content_list

 購入済みのミクコレの情報を取得

 OUTPUT
   成功時:ミクコレのデータのリスト
   失敗時:undef

=cut

sub get_paid_skin_content_list {
    my $class = shift;

    my %params = Params::Validate::validate(@_, {
        member_id => { type => Params::Validate::SCALAR, regex => qr/\A\d+\z/, },
        offset    => { optional => 1, default => 0, },
        limit     => { optional => 1, defalut => 10, },
    });

    my $content_list_response = _get_content_list_accessibility_by_app_id(
        requester_id     => $params{member_id},
        start_index      => $params{offset} + OFFSET2START_INDEX,
        quantity         => $params{limit},
        distribute_type  => 'owned',
    );
    return unless $content_list_response;
    _set_skin_data($content_list_response);

    return $content_list_response;
}

sub _get_content_list_accessibility_by_app_id {
    my %args = @_;
    return Mixi::Service::Procedure::InternalGateway->call(
        'jp.mixi.cpocket.accessibility.getContentListByAppId', {
            requester_id => $args{requester_id},
            params => {
                service_id       => SERVICE_ID,
                application_id   => APPLICATION_ID,
                start_index      => $args{start_index},
                quantity         => $args{quantity},
                distribute_type  => $args{distribute_type},
            },
        }
    );
}

=head2 set_member_skin_by_contnt_id

 ミクコレを設定する

 INPUT
   member_id
   content_id

 OUTPUT
   成功時: 1
   失敗時: 0

=cut

sub set_member_skin_by_content_id {
    my $class = shift;

    my %params = Params::Validate::validate(@_, {
        member_id  => { type => Params::Validate::SCALAR, regex => qr/\A\d+\z/, },
        content_id => { type => Params::Validate::SCALAR, regex => qr/\A\d+\z/, },
    });

    my $skins = Mixi::Skin::Touch->get_skins_by_content_ids(
        content_ids => [$params{content_id}]
    );
    return unless $skins && $skins->[0];
    my $skin = $skins->[0];

    return unless $class->get_display_status_by_content_id(
        owner_id   => $params{member_id},
        content_id => $params{content_id},
        _skin      => $skin,
    );

    return Mixi::Skin::Touch->new->set_member_skin(
        member_id => $params{member_id},
        skin      => $skin,
    );
}

sub _is_purchased_skin_legacy {
    my %args = @_;
    my $member_id = $args{member_id};
    my $skin      = $args{skin};

    return 1 if $skin->{skin_type} == Mixi::Skin::Touch::Config::SKIN_TYPE->{SIMPLE};

    return Mixi::Skin::Touch::Purchase->get_purchase_info_by_member_id_and_product_id(
        member_id  => $member_id,
        product_id => $skin->{id},
    ) ? 1 : 0;
}

=head2 get_display_status_by_content_id

 owner_idがミクコレを使用可能かチェックする

 INPUT
   owner_id
   content_id

 OUTPUT
   利用可能: 1
   利用不可: 0

=cut

sub get_display_status_by_content_id {
    my $class = shift;

    my %params = Params::Validate::validate(@_, {
        owner_id   => { type => Params::Validate::SCALAR, regex => qr/\A\d+\z/, },
        content_id => { type => Params::Validate::SCALAR, regex => qr/\A\d+\z/, },
        _skin      => { type => Params::Validate::HASHREF, optional => 1, }, # TODO: for legacy db
    });

    my $skin = $params{_skin};
    unless ($skin) {
        my $skins = Mixi::Skin::Touch->get_skins_by_content_ids(
            content_ids => [$params{content_id}]
        );
        # staging skinはまだ登録していないので、content_idがない。 
        # legacy purchase will not be checked!!!
        return unless $skins && $skins->[0];
        $skin = $skins->[0];
    }

    my $status_response = Mixi::Service::Procedure::InternalGateway->call(
        'jp.mixi.cpocket.accessibility.getDisplayStatus', {
            params => {
                owner_id       => $params{owner_id},
                application_id => APPLICATION_ID,
                content_ids    => [$params{content_id}],
            },
        }
    );

    return 1 if ($status_response && $status_response->{list}->[0]->{can_display});

    # TODO: remove later
    # Legacy Purchase DB fallback
    return 1 if _is_purchased_skin_legacy(
        member_id => $params{owner_id},
        skin      => $skin,
    );

    return 0;
};


sub _set_skin_data {
    my ($content_list_response, $skins) = @_;
    return unless($content_list_response->{total_results});

    my @content_ids = map {$_->{content_id}} @{$content_list_response->{content_list}};
    $skins ||= Mixi::Skin::Touch->get_skins_by_content_ids(content_ids => \@content_ids);

    my %content_id_to_skin = map { $_->{content_id} => $_ } @$skins;
    for my $content (@{ $content_list_response->{content_list} }) {
        my $skin = $content_id_to_skin{$content->{content_id}};
        unless ($skin) {
            Nove::Core::Log->warn("content_id [$content->{content_id}] is not exist in skin db");
            next;
        }
        $content->{skin_id}   = $skin->{id};
        $content->{skin_base} = $skin->{skin_base};
    }
}

1;
