package Mixi::Skin::Touch::Controller::Admin::List;
use strict;
use warnings;

use Mixi::Pages;
use List::Util qw(min);
use Mixi::Skin::Touch::Admin;
use Mixi::Skin::Config;
use Mixi::String qw/
    tune_html
    fold_text
/;

use constant {
    PER_PAGE => 30,
};

__PACKAGE__->auth_type(AUTH_UNREQUIRED);
__PACKAGE__->is_admin(1);
__PACKAGE__->charset('euc-jp');
__PACKAGE__->initial_params(
    page       => 1,
    mode       => 'all',
    genre_id   => undef,
    sort_key   => 'id',
    sort_order => 'desc',
);
__PACKAGE__->validation_and_warnings(
    _default => [
        mode        => [['IN_ARRAY' => "all",map { lc($_) } keys %{Mixi::Skin::Config::ADMIN_STATUS()}] => 'invalid parameter'],
        skin_type   => [['IN_ARRAY' => keys %{Mixi::Skin::Config::REVERSED_TOUCH_SKIN_TYPE()}]          => 'invalid parameter'],
        genre_id    => [['UINT']                                                                        => 'invalid parameter'],
        page        => [['POSITIVEINT']                                                                 => 'invalid parameter'],
        sort_key    => [['IN_ARRAY' => qw/id name open_datetime close_datetime regist_datetime update_datetime admin_status/] => 'invalid parameter'],
        sort_order  => [['IN_ARRAY' => qw/asc desc/]                                                    => 'invalid parameter'],
    ],
);
__PACKAGE__->assign(_default => [ \&assign_common,\&assign_default ]);
__PACKAGE__->templates(_default => 'touch/list_skin_simple.tmpl');
__PACKAGE__->conditions(
    _prepare => sub {
        my $self = shift;
        return $self->alert if $self->has_error;

        $self->stash->{skin_module} = Mixi::Skin::Touch::Admin->new(
            skin_type   => $self->param->{skin_type},
        );

        if($self->mode ne 'all'){
            $self->stash->{admin_status} = Mixi::Skin::Config::ADMIN_STATUS->{uc($self->mode)};
        }
        $self->template->param(%{$self->stash->{skin_module}->get_edit_skin_count()});
    },
);

sub assign_common {
    my $self = shift;

    my $all_genres = $self->stash->{skin_module}->get_all_genres();
    for(@$all_genres){
        $_->{genre_name} = $_->{id} . " : " . $_->{genre_name};
    }
    @$all_genres = sort {
       $a->{id} <=> $b->{id}
    } @$all_genres;

    my @all_admin_status_label = sort {
       $a->{sort_key} <=> $b->{sort_key}
    } map {
        {
            key      => lc($_),
            value    => Mixi::Skin::Config::ADMIN_STATUS_LABEL->{$_},
            sort_key => Mixi::Skin::Config::ADMIN_STATUS->{$_},
        }
    } keys %{Mixi::Skin::Config::ADMIN_STATUS()};

    $self->template->param(
        all_genres             => $all_genres,
        all_admin_status_label => \@all_admin_status_label,
    );
}

sub assign_default {
    my $self = shift;

    my $skins = $self->stash->{skin_module}->get_skins(
        admin_status => defined $self->stash->{admin_status} ? $self->stash->{admin_status} : undef,
        genre_id     => $self->param->{genre_id},
        sort_key     => $self->param->{sort_key},
        sort_order   => $self->param->{sort_order},
    );
    my ($page_from,$page_to,$has_next_page) = $self->_paging($skins);

    for(@$skins){
        $_->{list_color} = Mixi::Skin::Config::ADMIN_STATUS_COLOR_PALETTE->{Mixi::Skin::Config::REVERSED_ADMIN_STATUS->{$_->{admin_status}}};
        $_->{skin_type}  = Mixi::Skin::Config::SKIN_TYPE_LABEL->{(Mixi::Skin::Config::REVERSED_TOUCH_SKIN_TYPE->{$_->{skin_type}})};
        $_->{genres}     = join (' ',map { $_->{genre_name} } @{$_->{genres} || []});

        $_->{name}       = fold_text($_->{name},20, 2);
        $_->{genres}     = fold_text($_->{genres},10, 2);
    }

    my $skin_type_label = defined $self->param->{skin_type}
        ? Mixi::Skin::Config::SKIN_TYPE_LABEL->{Mixi::Skin::Config::REVERSED_TOUCH_SKIN_TYPE->{$self->param->{skin_type}}}
        : defined $self->param->{mode}
        ? Mixi::Skin::Config::ADMIN_STATUS_LABEL->{uc($self->param->{mode})}
        : '';

    $self->template->param(
        mode             => $self->param->{mode},
        current_genre_id => $self->param->{genre_id},
        page             => $self->param->{page},
        sort_key         => $self->param->{sort_key},
        sort_order       => $self->param->{sort_order},
        skins            => $skins,
        page_from        => $page_from,
        page_to          => $page_to,
        has_next_page    => $has_next_page,
        skin_type_label  => $skin_type_label,
        skin_type        => $self->param->{skin_type},
    );
}

sub _paging {
    my ($self,$skins) = @_;
    my $page_from     = ($self->param->{page} - 1) * PER_PAGE;
    my $page_to       = min($page_from + PER_PAGE - 1,scalar @$skins -1);
    my $has_next_page = 1 if defined $skins->[$page_to + 1];
    @$skins           = @$skins[$page_from..$page_to];
    return ($page_from,$page_to,$has_next_page);
}

1;
